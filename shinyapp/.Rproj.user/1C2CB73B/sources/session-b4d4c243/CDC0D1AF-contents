---
title: "ACP communes"
author: "Gabriel Macé"
date: "2024-06-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE)
```

```{r, include=FALSE}
library(readxl)
library(writexl)
library(stringr)
library(tidyr)
library(sf)
library(dplyr)
library(stats)
library(ggplot2)
library(stats)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(fastDummies)
library(plotly)
library(reshape2)
```

```{r}
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```

```{r}
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$insee_com %in% c("38453","38278", "38526", "38194", "38118", "38013", "38248", "38450", "38236", "38412", "38405", "38442", "38446", "38378"),]
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]
# data <- data[!is.na(data$transfert_facture),]

binaire <- read_excel("../data/2_Travail/export_questionnaire_binaire.xlsx")
binaire <- binaire[binaire$`N° dossier` %in% data$N..dossier,]
binaire <- binaire[,c(1,50:54)]
binaire <- left_join(binaire, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire <- binaire[!duplicated(binaire$`N° dossier`),c(2:7)]
# regrouper certaines modalités de la raison du changement d'appareil
binaire$`Qualité_air` <- binaire$`Qualité air de mon logement` + binaire$`Qualité de l'air extérieur`
binaire[binaire$`Qualité_air` == 2,]$`Qualité_air` <- 1
binaire$économiser <- binaire$`Économiser de l'argent` + binaire$`Économiser du bois/énergie`
binaire[binaire$économiser == 2,]$économiser <- 1
binaire <- binaire[, c(4,6:8)]
```


```{r}
data_acp <- data[,c(1,43)] %>% group_by(insee_com) %>% count()

#quanti = c("cout_total_TTC", "montant_aide","cout_appareil") # , "équivalent_steres"
quali = c("Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration"
          )
#  "Année.installation",
for(col in quali){
df_long <- data[,c(col, "insee_com")]
df_long <- dummy_cols(df_long, select_columns = col, remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, df_binary, by = "insee_com")
}

df <- data[,c("insee_com","cout_total_TTC")] %>% group_by(`insee_com`) %>% summarise(cout_total_TTC = mean(na.omit(cout_total_TTC)))
data_acp <- left_join(data_acp, df, by = "insee_com")

df <- data[,c("insee_com","montant_aide")] %>% group_by(`insee_com`) %>% summarise(montant_aide = mean(na.omit(montant_aide)))
data_acp <- left_join(data_acp, df, by = "insee_com")

binaire2 <- binaire %>% group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, binaire2, by = "insee_com")

for(i in setdiff(names(data_acp), c("insee_com", "n", "montant_aide"))){
  data_acp[,i] = data_acp[,i] / data_acp$n
}
terr = data[,c("Territoire","insee_com")]
terr = terr[!duplicated(terr$insee_com),]
data_acp <- left_join(data_acp, terr, by = "insee_com")
```

```{r}
names(data_acp) <- c("insee_com", "n",
                     "old_foyer_ouvert", "old_insert_fermé", "Type.Ancien.appareil_Pas de réponse", "old_Poêle", 
                     "old_appoint", "old_principal", "Usage.ancien.matériel_Pas de réponse", "old_agrément", 
                     "new_insert_fermé", "Nouveau.matériel_Pas de réponse", "new_Poêle", 
                     "Type.combustible.nouveau.materiel_autre", "Bûche", "Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", 
                     "new_appoint", "new_principal", "Usage.nouveau.matériel_Pas de réponse", "new_agrément", 
                     "majorée", "majoration_NM", "majoration_NA", "cout_total_TTC", "montant_aide",
                     "confort", "Qualité_air","économiser", "Territoire")
```


```{r, include=FALSE}
comm <- read.csv("../data/siddt.csv", sep = ";", skip = 2)[-c(124:130),c(1,2, 3,4,6)]
comm2 <- read.csv("../data/siddt2.csv", sep = ";", skip = 2)[-c(124:130),c(1, 3:5)]
logement = read.csv("../data/logements_2020.csv", sep =";", skip= 2)[-c(124:130),c(1,7,8)]
objectifs_communes <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[1:123,1:4]
oc <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[124:239,c(2,4)]
objectifs_communes <- left_join(objectifs_communes, oc, by = "id_comm")
objectifs_communes$id_comm = as.character(objectifs_communes$id_comm)
objectifs_communes = objectifs_communes[,c(2,4,5)]
names(objectifs_communes)= c("insee_com", "objectifs_2022", "changement_2023")
objectifs_communes$changement_2023 = abs(objectifs_communes$changement_2023)
objectifs_communes[is.na(objectifs_communes$changement_2023), "changement_2023"] <- 0
revenus_communes <- read_xlsx("../data/revenu_communes_insee.xlsx", skip = 5, col_names = TRUE)
revenus_communes <- revenus_communes[revenus_communes$CODGEO %in% data$insee_com,]
revenus_communes = revenus_communes[, c(1, 3:5)]
names(revenus_communes) = c("insee_com", "nb_ménages_fiscaux", "nb_personnes_menages_fiscaux", "mediane_niveau_vie")
types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome très peu dense", "rural autonome peu dense",  "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
surf_bois <- read_excel("../data/surface_boisee_off_2023.xlsx", sheet = "données")
surf_bois = surf_bois[surf_bois$`INSEE commune` %in% data$insee_com,c("INSEE commune", "Surface commune", "feuillus", "mixtes")]
```


```{r}
count <- data %>%
  group_by(insee_com) %>%
  count()
fo <- data[data$Type.Ancien.appareil != "Foyer ouvert",] %>%
  group_by(insee_com) %>%
  count()
buche <- data[data$Type.combustible.nouveau.materiel == "Bûche",] %>%
  group_by(insee_com) %>%
  count()
maj <- data[data$majoration == "M",] %>% group_by(insee_com) %>% count()
names(comm) <- c("communes.depcom","commune", "superficie_foret", "taux_forets", "évolution_nb_logements")
data_test = left_join(count, comm, by = join_by("insee_com" == "communes.depcom"))
names(comm2) <- c("communes.depcom", "Densité_pop", "Part_résidences_principales_loc", "part_maisons")
data_test <- data_test %>% left_join(comm2, by = join_by("insee_com" == "communes.depcom"))
names(logement) = c("insee_com","nb_maisons_rp_2020", "part_résidences_principales")
data_test <- data_test %>% left_join(logement, by = "insee_com")
data_test <- data_test %>% left_join(types_communes, by = "insee_com")
data_test <- data_test %>% left_join(objectifs_communes, by = "insee_com")
data_test <- data_test %>% left_join(revenus_communes, by = "insee_com")
data_test <- na.omit(data_test)
data_test[, "taux_dossiers_habitant"] = data_test$n / as.numeric(data_test$nb_personnes_menages_fiscaux)
data_test[, "taux_changement"] = data_test$changement_2023 / data_test$objectifs_2022
data_test[, "objectifs_2022_par_maison"] = data_test$objectifs_2022 / as.numeric(data_test$nb_maisons_rp_2020)
data_test[, "taux_feuillus"] = surf_bois$feuillus / surf_bois$`Surface commune`
data_test[, "taux_feuillus_mixte"] = (surf_bois$feuillus + surf_bois$mixtes) / surf_bois$`Surface commune`
```



# <span style="color: red;"> <u> Ensemble des demandeurs de prime : </u> </span>

## Test de normalité de Shapiro-Wilk :

Nous allons tester la normalité des distributions, afin d'identifier un éventuel effet "commune".

Si les comportements des bénéficiaires sont les mêmes dans chaque commune, alors les distributions devraient être normales.

H0 : "La distribution suit une loi normale".

Etant donné que je fais 31 tests, j'utilise la correction de Benjamin-Hochberg :

```{r, include = FALSE}
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
pval = c()
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
    qqnorm(data_acp %>% pull(col), main = col)
  plot(density(data_acp %>% pull(col)), main = col)
    pval = c(pval, shapiro.test(data_acp %>% pull(col))$p.value) # H0 : la distribution suit une loi normale
}

res = data.frame(var = setdiff(names(data_acp), c("insee_com","Territoire")), p_valeur =  p.adjust(pval, method = "BH", n = length(pval)))
```
Seules 2 des 31 variables sont normalement distribuées.
```{r, include = FALSE}
# Les variables ne suivant pas une loi normale : 
res[res$p_valeur < 0.05,]
```


```{r, include = FALSE}
# Les variables normalement distribuées :
res[res$p_valeur > 0.05,] # que 2 distributions normales
```






## ACP :

Je ne garde pas les communes ayant moins de 10 dossiers

Variables utilisées : 
"Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration", "cout_total_TTC, et "Motivation changement appareil"

J'enlève les variables représentant les modalités de type "autre", "pas de réponse, "NA", et une des modalités des variables devenues binaires (combustible, majoration)
```{r}
data_acp <- data_acp[,setdiff(names(data_acp),c("Type.Ancien.appareil_Pas de réponse", "Usage.ancien.matériel_Pas de réponse", "Nouveau.matériel_Pas de réponse", "Type.combustible.nouveau.materiel_autre","Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", "Usage.nouveau.matériel_Pas de réponse", "majoration_NA"
                                                ,"new_insert_fermé", "Granulés", "majoration_NM"
                                                # , "Qualité air de mon logement","Économiser du bois/énergie","Économiser de l'argent","Gagner en confort/chaleur", "Qualité de l'air extérieur"
))]

# variable devenues binaires :
# ,"Nouveau.matériel_Insert / foyer fermé", "Type.combustible.nouveau.materiel_Granulés", "majoration_NM"
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
for(col in setdiff(names(data_test), c("insee_com","commune","type_commune"))){
  data_test[,col] <- as.numeric(data_test %>% pull(col))
}

```

```{r, include = FALSE}
data_acp <- data_acp[data_acp$insee_com %in% data_test$insee_com,]
data_acp = data_acp[data_acp$n >= 10,]
df = left_join(data_acp, data_test[,setdiff(names(data_test),c("n","commune"))], by = "insee_com")
df$montant_aide = df$montant_aide / df$nb_ménages_fiscaux
res.pca <- PCA(df[, 2:dim(df)[2]], quanti.sup = c("n", "montant_aide", setdiff(names(data_test),"type_commune")),quali.sup = c("Territoire","type_commune"), ncp = 10)
```
### Valeurs propres :
```{r}
eig.val <- get_eigenvalue(res.pca)
head(eig.val, n = 10)
```
Les 6 premières dimensions expliquent quaisment 80% de la vairance, on gardera quand même les 10 premières pour les clusterings.

```{r}
#row.names(res.pca$ind$coord) <- na.omit(data_afdm)$commune
fviz_pca_ind(res.pca, habillage = "Territoire", palette = c("green","red", "blue"))
```

Il semble y avoir une légère séparation par territoire, sur les deux premières dimensions.

```{r}
fviz_pca_var(res.pca, select.var = list("contrib" = 10))
```
### Contribution et représentation des variables : 

```{r}
#La fonction fviz_eig() ou fviz_screeplot() [factoextra] peut être utilisée pour visualiser les proportions de variances expliquées par les différents axes:
  fviz_screeplot(res.pca)
```

```{r}
var = get_pca_var(res.pca)
corrplot(var$contrib[,1:10], is.corr = FALSE) 
corrplot(var$cos2[,1:10], is.corr = FALSE) # qualité de représentation
fviz_contrib(res.pca, choice = "var", axes = c(1,2))
fviz_cos2(res.pca, choice = "var", axes = c(1,2))
```
Les variables de raisons de changement d'appareil, et le cout ttc des travaux ne semblent pas très importants.
Les autres semblent toutes assez bien représentées par les deux premières dimensions.
### Type de communes  :

```{r}
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5"))
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 4), "red", "red"))
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 3), rep("green",2), "red"))
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("yellow","yellow", "orange", "red", "brown", "black"))
```

Les deux premières dimensions semblent bien séparer les communes urbaines des rurales

## Clustering :
### Clustering ascendant hiérarchique : 

```{r}
row.names(res.pca$ind$coord) <- data_acp[data_acp$n >= 10,]$insee_com
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D")
plot(hc)
rect.hclust(hc,k=2)

memb <- as.factor(cutree(hc, k = 3))
fviz_pca_ind(res.pca, col.ind = memb, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D2")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 3))
fviz_pca_ind(res.pca, col.ind = memb, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
```

Le dendogramme semble suggérer de créer 2 clusters, voir 3.

### K-means :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)# Créez 2 groupes de variables (centers = 2)
grp <- as.factor(res.km$cluster)
# Colorer les variables par groupes
fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, axes = c(1,3))
fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, axes = c(2,3))
```

La méthode k-means semble bien séparer les deux groupes, en particulier selon la première dimension.



```{r}
fviz_pca_biplot(res.pca, col.var = "bisque4", label = c( "var"), select.var = list("contrib" = 9), col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"),repel = TRUE)
```

```{r}
fviz_pca_biplot(res.pca, col.var = "transparent", label = "quanti.sup", col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), repel = TRUE)
```


### Carte des clusters : 


```{r}
# Get polygons communes data
sql <- "SELECT insee_com, nom_m AS nom_commune, the_geom 
        FROM bd_admin_express.geo_commune_2022
        WHERE insee_dep = '38'
		    ORDER BY 1"
layer_communes <- st_read(con, query = sql)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]

shp <- st_read(dsn = "../data/EPCI 2024_region.shp")
shp = shp[c(27, 175, 929),]
shp$ sociale <- c("CCLG", "GAM", "CAPV")
```

```{r}
grp <- data.frame(grp)
grp$insee_com = rownames(grp)
to_plot <- left_join(layer_communes, grp, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = grp)) +
  #scale_fill_gradient(low = "white", high = "blue", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = grp), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

## Carte du type de commune
```{r}
tp2 = types_communes[types_communes$insee_com %in% data$insee_com,]
levels(tp2$type_commune) <- c("rural", "rural", "rural","rural", "urbain", "urbain")

to_plot <- left_join(layer_communes, tp2, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  #scale_fill_gradient(low = "white", high = "blue", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

```{r}
to_plot <- left_join(layer_communes, types_communes, by = "insee_com")
col = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  scale_fill_manual(values = c("rural autonome peu dense" = col[1], "rural autonome très peu dense" = col[2], "rural sous faible influence d'un pôle" = col[3], "rural sous forte influence d'un pôle" = col[4], "urbain densité intermédiaire" = col[5], "urbain dense" = col[6] )) +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

## Lien entre les cluters et les types de communes
```{r}
table <- table(grp$grp, tp2[tp2$insee_com %in% data_acp$insee_com,]$type_commune)
table
```
Deux groupes : un plus urbain, l'autre plus rurale mais pas mal de confusion
      rural urbain
  1    37     22
  2    10     42

Trois groupes : un urbain, un rural, un mixte

    rural urbain
  1     4     31
  2    22     33
  3    21      0
  
  
```{r}
t = t(addmargins(table))
t = t / t[,3]
t = t[1:2,1:2]
round(t,2)
```



```{r}
table2 <- table(grp$grp, types_communes[types_communes$insee_com %in% data_acp$insee_com,]$type_commune)
table2
```
Groupe 1 = Rurales
Groupe 2 = rural sous faible influence d'un pôle, rural sous forte influence d'un pôle, urbain (principalement intermédiaire)
Communes intermédiaires ?
Groupe 3 = urbain + rurale sous forte influence d'un pôle

```{r}
t2 = t(addmargins(table2))
t2 = t2 / t2[,3]
t2 = t2[1:6,1:2]
round(t2,2)
```

```{r, include = FALSE }
ggplot(data = melt(t), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()

ggplot(data = melt(t2), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```


```{r}
# # Créez une variable de regroupement en utilisant kmeans
# set.seed(23)
# res.km <- kmeans(res.pca$ind$coord, centers = 6, nstart = 25)# Créez 3 groupes de variables (centers = 3)
# grp <- as.factor(res.km$cluster)
# # Colorer les variables par groupes
# fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
```




## Comparaison Urbain / rural

```{r}
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "rural",]$Type.combustible.nouveau.materiel_Bûche)
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "urbain",]$Type.combustible.nouveau.materiel_Bûche)

# data <- left_join(data, types_communes, by = "insee_com")
# data <- left_join(data, tp2, by = "insee_com")
# boxplot(data_acp$Type.combustible.nouveau.materiel_Bûche ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# boxplot(data_acp$Type.combustible.nouveau.materiel_Granulés ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.y)/ table(data$type_commune.y)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.y)/ table(data$type_commune.y)
```


```{r}
# check <- data[, c("adresse_ville", "insee_com", "Type.combustible.nouveau.materiel", "type_commune.x")]
# check_gre <- check[check$adresse_ville %in% c("GRENOBLE"),c(3)]
# write_xlsx(check, "../data/3_Resultat/check_communes.xlsx")
# write_xlsx(check_gre, "../data/3_Resultat/check_Grenoble.xlsx")
```
## Différences inter-groupes : 

```{r}
# interprétation des variables / groupes
stat.comp <- function(x,y){
  K <- length(unique(y))# Nombre de groupes
  n <- length(x)# Nombre d’observations
  m <- mean(x)# Moyenne globale
  TSS <- sum((x-m)^2) # Variabilité totale
  nk <- table(y) # Effectifs conditionnels
  mk <- tapply(x,y,mean) # Moyennes conditionnelles
  BSS <- sum(nk * (mk - m)^2) # Variabilité expliquée
  result <- c(mk,100.0*BSS/TSS) # Moyennes + prop. variance expliquée
  names(result) <- c(paste("G",1 :K),"% epl.")# Nommer les élements du vecteur
  return(result) # Renvoyer le vecteur résultat
}

```


```{r}
data_test = data_test[data_test$n >=10, ]
data_test_cr = data_test
data_test_cr = data.frame(data_test_cr)
```

```{r}
for(i in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
  data_test[,i] <- as.numeric(data_test %>% pull(i))
  data_test_cr[,i] <- scale(as.numeric(data_test %>% pull(i)))
}
```

```{r}
set.seed(3)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)
grp <- as.factor(res.km$cluster)
```

#### Récupération des clusters par communes : 

```{r}
# entree <- data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
# sortie <- data.frame(cluster_com = grp, insee_com = rownames(as.data.frame(grp)))
# sortie <- left_join(entree, sortie, by = "insee_com")
# write_xlsx(sortie, "../data/3_Resultat/data_questionnaire_complet.xlsx")
```

### Variables de l'ACP :
Le tableau présente les différences de moyennes entre les deux groupes, pour les variables centrées réduites (cr) ou brutes, ainsi que la proportion de variance de la variable expliquée par la séparation en groupes (X..epl).

Il est ordonné selon la différence de moyennes  inter-groupes (pour les variables centrées réduites).

```{r}
var = setdiff(names(data_acp), c("insee_com","Territoire","n"))
df = data_acp[data_acp$n >= 10, var]
df = scale(df)
df = data.frame(df)
t = data.frame(round(sapply(df,stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_acp[data_acp$n >= 10, var],stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"
```{r}
res = c()
anova = c()
for(v in names(df)){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(df[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(df[,v]~grp))[[1]][1,5] )
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
```


```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```

```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr, 1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon","pval anova", "index")
dataf
```
Groupe 1 : (+ rural)
```{r}
dataf[dataf$Diff_grp > 0,]$variables
```
Majorés, chauffage principal, raison changmenet : plus de modalités / croisement, taux de poêle nouveau ++, ancien : plus d'insert


Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0,]$variables
```

Non majorés, ont un usage moins important de leur appareil (moins dépendants), taux de buche + important

```{r}
write_xlsx(dataf, "var_acp.xlsx")
```


### Variables supplémentaires : 

```{r}
# rl ?
var = setdiff(names(data_test), c("insee_com", "type_commune", "commune", "Territoire", "changement_2023", "nb_maisons_rp_2020")) # , "n", "objectifs_2022"
t = data.frame(round(sapply(data_test_cr[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_test[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"

```{r}
res = c()
anova = c()
#kw = c()
for(v in var){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(data_test_cr[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(data_test_cr[,v]~grp))[[1]][1,5] )
  #kw <- c(kw, kruskal.test(data_test_cr[,v]~grp)$p.value)
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
#p_value_corr_kw = p.adjust(kw, method = "BH", n = length(kw))
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr,  xlim = c(-1.5, 1.5), ylim = c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")# , col = "transparent"
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```

```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr,1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon", "pval anova", "index")
dataf
```

Groupe 1 : (+ rural)
```{r}
dataf[dataf$Diff_grp > 0,]$variables
```
Plus de primes, plus de fôrets de tout type, plus grande part de maison dans les résidences principales


Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0,]$variables
```
Plus de pop, meilleur médiane de niveau de vie, taux plus important de superficie de feuillus

```{r}
write_xlsx(dataf, "var_expl.xlsx")
```

```{r}
ordre = ordre[,c(1,3)]
ordre$inégalité_distributions = dataf$`pval wilcoxon` < 0.05
ordre$définition = rep("à déf", 17)
ordre <- ordre[,c(4,3,2,1)]
ordre
```

### Liens entre les variables de l'acp

```{r, include=FALSE}
# lm : H0 : X n'a pas d'effet sur Y
library(car)
p_value_correlation = c()
co = c()
p_value_lm = c()
var1 = c()
var2 = c()
r2 = c()
quanti2 = c()
for(q in setdiff(names(data_acp), c("insee_com","Territoire","n"))){
  quanti2 = c(quanti2, q)
   for(q2 in setdiff(setdiff(names(data_acp), c("insee_com","Territoire","n")), quanti2)){
      ct = cor.test(as.numeric(data_acp %>% pull(q)), data_acp %>% pull(q2))
      p_value_correlation = c(p_value_correlation, ct$p.value)
      p_value_lm = c(p_value_lm,summary(lm(data_acp %>% pull(q2)~data_acp %>% pull(q)))$coefficients["data_acp %>% pull(q)", "Pr(>|t|)"]) # q explique as.numeric(grp)
      r2 =  c(r2,summary(lm(data_acp %>% pull(q2)~data_acp %>% pull(q)))$r.squared)
      co = c(co, ct$estimate)
      var1 = c(var1, q)
      var2 = c(var2, q2)
   }
}
res_corr = data.frame(q1 = var1, q2 = var2, correlation = round(co,3), p_value_corr = p.adjust(p_value_correlation, method = "BH", n = length(p_value_correlation)), r2 = round(r2,3), p_value_lm_ajustée = p.adjust(p_value_lm, method = "BH", n = length(p_value_lm)))

res_corr
```

```{r}
res_corr[res_corr$q1 == "new_Poêle" | res_corr$q2 == "new_Poêle",]
```

```{r}
 summary(lm(new_Poêle ~ new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              #old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
            #* Bûche * 
              , data = data_acp))
```

Le taux de nouveaux appareils de type poêle est lié et anti corrélé aux taux de : bûches, nouveaux et anciens appoints, nouveaux et anciens aggréments, (montant de l'aide)

Lié et corrélé aux taux de : majoration, nouveaux et anciens principaux
Buche : appoint +, principal -

Majorée : anti corrélé au montant de l'aide : effet Pays Voironnais ? Beaucoup de maj, prime + faible
-> lié au cout total ttc

```{r}
res_corr[res_corr$q1 == "Bûche" | res_corr$q2 == "Bûche",]
```

```{r}
 summary(lm(Bûche  ~ old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
           # * new_Poêle* new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              , data = data_acp))
```
Taux de bûches lié et anti corrélé à : ancien et nouveau poêle, ancien principal, majoration

Lié et corrélé à : ancien foyer ouvert, ancien et nouveau appoint, ancien aggrément


#### Régression logistique :

```{r}
data_acp$grp = as.factor(grp)
```

```{r}
modele = (glm(grp  ~ old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
           # * new_Poêle* new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              , family = binomial(logit), data = data_acp))
#summary(modele)
# pseudo_R2 <- 1 - modele$deviance/modele$null.deviance
# pseudo_R2
# Dans le sommaire du résultat de glm, la déviance du modèle ajusté est indiquée comme Residual Deviance.
# Le sommaire inclut aussi une autre valeur, Null Deviance, qui correspond à la déviance du modèle nul ne
# comptant aucun prédicteur. Ces deux valeurs jouent un rôle semblable à la sommes des écarts carrés résiduels
# et la somme des écarts carrés totaux dans le modèle linéaire. On peut donc définir le pseudo R2 (ou R2 de
# McFadden) comme la fraction de la déviance du modèle nul expliquée par le modèle incluant les prédicteurs

r2_tjur <- mean(modele$fitted.values[modele$y == 1]) - mean(modele$fitted.values[modele$y == 0])
r2_tjur
# le R2 de Tjur mesure la différence entre la réponse moyenne prédite pour les cas où la réponse
# observée est 1 et la réponse moyenne prédite pour les cas où la réponse observée est 0. Il indique donc à quel
# point le modèle peut “séparer” les deux groupes y = 1 et y = 0. À l’extrême, un coefficient de 0 indique que
# le modèle prédit en moyenne la même réponse pour les deux groupes, tandis qu’un coefficient de 1 indique
# que le modèle prédit avec certitude la bonne réponse pour toutes les observations
```
On prédit très bien les groupes à partir des anciens usages


# Conclusion ensemble des demandeurs :

Suite à l'acp, nous avons chercher à créer des groupes de communes, le choix de séparer en deux groupes semble le plus optimal.
Le premier groupe contient principalement des communes rurales et une vingtaine de communes urbaines de densité intermédiaire.
Le deuxième groupe contient principalement des communes urbaines, et quelques communes rurales sous influence d'un pôle.

Les communes du premier groupe ont en moyenne un taux de prime majorées plus fort (12%), ont un taux plus fort de chauffage principal dans les anciens et nouveaux matériels (23 et22%), ont 13 % de plus de pôele dans les noveaux matériels, et remplissent plus de réponses dans les raisons de changement d'appariel,  par rapport au deuxième groupe.

Le deuxième groupe a un usage moins important des appareils (appoint, plaisir), avant comme après prime, et a un taux plus fort d'utilisation de la bûche dans les nouveaux appareils (15%).

Il est possible que les usages des appareils définissent le type d'appareil et de combustible (Chauffage principal -> poêle à bûche). Or les usages peuvent être liés à la situtation économique de l'usager (ex : majoration de la prime).

Pour les variables supplémentaires, il semble y avoir plus de demandes de primes par habitant, ainsi q'une plus grande part de maison dans les résidences principales. Dans le deuxième groupe, il semble y avoir plus de population, une plus forte médiane de niveau de vie. Ce qui conforte la séparation rural / urbain des deux groupes.
Les différences entre les taux de forêts sont très faibles (entre à et 2 %), et sont plus fort tantôt pour le groupe 1, tantot pour le 2, dépendant de la variable.

Il semble que les différences de comportement entre les deux groupes soient plutôt dues aux caractéristiques socio-économique des communes.





