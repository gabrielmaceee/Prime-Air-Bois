# Ici on met tous les pretraitements qio n'ont rien a voir avec l'interface (read data, etc)
# Pour l'instant on ne l'utilisera pas.
# On pmet tout dans server.R

library(shiny)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(janitor)
library(gridExtra)
library(sf)
library(ggspatial)
library(plotly)
library(mapview)
library(leafpop)
library(leaflet)

# T1<-Sys.time()
# data <- read_excel("www/data/data.xlsx")
# enquete <- read_excel("www/data/Enquête qualitative.xlsx")
# dico <- read_excel("www/data/dico.xlsx")
# T2<-Sys.time()

# libelles <- names(data)
# data <- data %>% 
#   clean_names()
# column_names <- names(data)
# df <- data.frame(
#   id = column_names,
#   name = libelles
# )
# write_xlsx(df , "www/data/dico.xlsx")
#write_xlsx(data , "www/data/data.xlsx")
# enquete <- enquete %>%
#   clean_names()


# data[ data$date_refus == "NaN",]$date_refus <- NA
# write.csv(data, "www/data/data.csv")
# write.csv(enquete, "www/data/Enquête qualitative.csv")
# write.csv(dico, "www/data/dico.csv")
# T1<-Sys.time()
data <- read.csv("www/data/data.csv") 
enquete <- read.csv("www/data/Enquête qualitative.csv")
dico <- read.csv("www/data/dico.csv")
# T2<-Sys.time() # 3 fois plus rapide : gain = 1/2 seconde



data$revenus <- factor(data$revenus, levels = rev(c("Pas de réponse", "Moins de 20 000 €", "20 000 à 30 000 €", "30 000 à 40 000 €", "40 000 à 50 000 €",
                                                "50 000 à 60 000 €", "60 000 à 70 000 €", "70 000 à 80 000 €", "80 000 à 90 000 €", "Plus de 100 000 €")))
data$usage_ancien_materiel <- factor(data$usage_ancien_materiel, levels = c("Chauffage principal", "Chauffage d'appoint", 
                                                                            "Plaisir / agrément",  "Pas de réponse")) 
data$usage_nouveau_materiel <- factor(data$usage_nouveau_materiel, levels = c("Chauffage principal", "Chauffage d'appoint", 
                                                                            "Plaisir / agrément",  "Pas de réponse")) 

data$dossier_recu <- as.Date(data$dossier_recu)
data$transfert_facture <- as.Date(data$transfert_facture)
data$date_dossier_complet <- as.Date(data$date_dossier_complet)
data$date_refus <- as.Date(data$date_refus)





column_names  <- dico %>% filter(to_plot == 1) 
couleur_terr <- data.frame(territoire = c("Tous", "CAPV", "GAM", "CCLG"), couleur = c("gray60", "green", "blue", "red"))

no_plot <- c("N..dossier", "adresse_ville", "insee_com", names(data[,42:74]))
quanti <- c("Nb.pers.ménage", "Surf chauff logement", "équivalent_steres", "cout_appareil", "cout_total_TTC", "kwh", "montant_aide" )
tempo <- c("dossier_reçu", "Date_dossier_complet", "Date_refus")
quali <- setdiff(names(data), c(no_plot, quanti, tempo))
qcm <- c("Motivation du changement", "Connaissance aide", "Travaux isolation depuis 2005", "Période utilisation")


# Créer une séquence de dates avec un pas d'un mois
start_date <- as.Date("2016-01-01")
end_date <- as.Date("2023-12-01")
date_vector <- format(seq.Date(from = start_date, to = end_date, by = "month"), "%Y-%m")


get_graph <- function(df, colname, couleur){
  column_cara <- column_names %>% 
    filter(id == colname)
  if(column_cara$type == "quanti"){
    x = as.numeric(na.omit(df %>% pull(colname)))
    p <- ggplot(df,aes(x = df %>% pull(colname))) + geom_density(color= couleur) + ggtitle(column_cara$definition) +  theme(axis.title.x=element_blank())
    data_summary <- data.frame(
      Statistiques = c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum", "Variance"),
      Valeurs = round(c(summary(x), var(x)), 2)
    )
    # Créer un tableau interactif avec plotly
    plotly_tab <- plot_ly(
      type = 'table',
      header = list(
        values = c("Statistiques", "Valeurs"),
        align = c('center'),
        line = list(width = 1, color = 'black'),
        fill = list(color = 'grey'),
        font = list(family = "Arial", size = 12, color = "white")
      ),
      cells = list(
        values = rbind(data_summary$Statistiques, data_summary$Valeurs),
        align = c('center'),
        line = list(color = "black", width = 1),
        fill = list(color = c('white', 'lightgrey')),
        font = list(family = "Arial", size = 11, color = c("black"))
      )
    )
    fig <- subplot(plotly_tab, ggplotly(p), nrows = 2, shareX = FALSE)
    fig
  }
  else if(column_cara$type == "quali"){
    p <- ggplot(df, 
           aes(x = df %>% pull(colname))) + 
      geom_bar(stat = 'count', fill = couleur) + 
      ylim(0, max(table(data %>% pull(colname)))) +
      coord_flip() + 
      ggtitle(column_cara$definition) +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank())
      ggplotly(p)
  }
  else if(column_cara$type == "tempo"){
    df <- df[ df %>% pull(colname) > "2016-01-01" & df %>% pull(colname) < "2024-01-01",]
    temp = df %>% pull(colname)
    # par mois
    nb_mois <- format(temp,"%m")
    p1 <- ggplot(as.data.frame(table(nb_mois)),aes(x = nb_mois, y  = Freq)) + geom_bar(stat = 'identity', fill = couleur)
    p1 <- ggplotly(p1, tooltip = c("x", "y"))
    # par an : enlever 2024
    nb_an <- format(temp, "%Y")
    p2 <- as.data.frame(table(nb_an)) %>%
      ggplot(aes(x = nb_an, y  = Freq,  group = 1)) + geom_point(color = couleur) + geom_line(color = couleur)
    p2 <- ggplotly(p2, tooltip = c("x", "y"))
    
    #par mois et an #par mois et an #par mois et an 
    date = data.frame(date = date_vector)
    nb_mois_an <- data.frame(table(sort(format(temp, "%Y-%m"))))
    date = left_join(date, nb_mois_an, by = join_by("date" == "Var1"))
    if(sum(is.na(date$Freq)) != 0) date[is.na(date$Freq),]$Freq <- 0
    nb_doss <- ts(date$Freq, start = c(2016, 1), end = c(2023,12), freq = 12)
    p3 <- data.frame(origine = date$Freq, dec = decompose(nb_doss)$trend, date = date$date ) %>%
      ggplot() +
      geom_line(aes(x = date, y = origine, group = 1), color = couleur) +
      geom_line(aes(x = date, y = dec, group = 1), color = "black")
    p3 <- ggplotly(p3, tooltip = c("x", "y"))
    fig <- subplot(p1, p2, p3, nrows = 1, shareX = FALSE)
    fig
  }
  else if(column_cara$type == "qcm"){
    # column_bin <- dico %>% filter(definition == colname)
    # barplot(colSums(df[, column_bin$id]), col = couleur, main = column_cara$definition, las = 1, ylim = c(0, max(colSums(data[, column_bin$id]))))

    column_bin <- dico %>% filter(definition == colname)
    summed_values <- colSums(df[, column_bin$id])
    summed_df <- data.frame(Item = names(summed_values), Count = summed_values)
    
    p <- ggplot(summed_df, aes(x = Item, y = Count)) +
      geom_bar(stat = 'identity', fill = couleur) +
      ggtitle(column_cara$definition) +
      theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
      ylim(0, max(summed_df$Count))
    ggplotly(p)
    }
}



### carto : 
layer_communes <- st_read("www/data/layer_count.shp")
names(layer_communes)[1:2] <- c("insee_com", "nom_commune")
layer_communes$insee_com <- as.integer(layer_communes$insee_com)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]
shp <- st_read(dsn = "www/data/EPCI 2024_region.shp")
shp <- shp[c(27, 175, 929),c("geometry")]
shp$sociale <- c("CCLG", "GAM", "CAPV")
names(shp)[2] <- "Territoire"
pop <- read.csv("../data/population.csv", sep = ";", skip = 2)[1:123, c(1,3)]
pop$communes.depcom <- as.integer(pop$communes.depcom)
carto <- function(){
count <- data %>%
  group_by(insee_com) %>%
  count()
layer_communes = layer_communes %>% left_join(count)
layer_communes = layer_communes %>% left_join(pop, by = join_by("insee_com" == "communes.depcom"))

to_plot <- layer_communes %>%
          mutate(dossier_par_habitant = n/Population.en.2020)
# Créer la carte interactive avec mapview
map <- mapview(shp, col.regions = c("red", "blue", "green"), layer.name = "Territoire", legend = FALSE)
map <- map + mapview(to_plot, zcol = "dossier_par_habitant",
               col.regions = colorRampPalette(c("white", "blue")),
               legend = TRUE,
               layer.name = "Taux de dossiers par habitants",
               popup = leafpop::popupTable(to_plot, 
                                           zcol = c("nom_commune", "insee_com", "dossier_par_habitant", "n", "Population.en.2020"), row.numbers = FALSE),
               hide = FALSE)

map <- map + mapview(to_plot, zcol = "n",
                     col.regions = colorRampPalette(c("white", "blue")),
                     legend = TRUE,
                     layer.name = "Nombre de dossiers",
                     popup = leafpop::popupTable(to_plot, zcol = c("nom_commune", "insee_com", "n", "Population.en.2020"), row.numbers = FALSE), 
                     hide = TRUE)

map <- map + mapview(to_plot, zcol = "Population.en.2020",
                     col.regions = colorRampPalette(c("white", "blue")),
                     legend = TRUE,
                     layer.name = "Population",
                     popup = leafpop::popupTable(to_plot, zcol = c("nom_commune", "insee_com", "Population.en.2020"), row.numbers = FALSE), hide = TRUE)

leaflet_map <- map@map 
leaflet_map
}




#### Graphiques spécifiques : 
# Sélectionner que les années d'interêt :
df <- data[data$dossier_recu > "2016-01-01" & data$dossier_recu < "2024-01-01" & !is.na(data$dossier_recu),]
df$dossier_recu <- format(df$dossier_recu, "%Y")

# La prime et ses bénéficiaires : 

demande_territoire <- function(){
plot <- df %>%
  group_by(dossier_recu, territoire) %>%
  summarise(n = n()) %>%
  ggplot(aes(x = dossier_recu, y =  n, group = territoire, color = territoire)) +
  geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
                                 x = "Année",
                                 y = "Nombre de primes majorées") +
  scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("x", "y", "group"))
plotly_plot
}



taux_majoration <- function(){
  counts_pv = table(df[df$majoration == "M" & df$territoire == "CAPV" ,]$dossier_recu)/ table(df[df$territoire == "CAPV" ,]$dossier_recu)
  counts_g = table(df[df$majoration == "M" & df$territoire == "CCLG" ,]$dossier_recu)/ table(df[df$territoire == "CCLG" ,]$dossier_recu)
  counts_gam = table(df[df$majoration == "M" & df$territoire == "GAM" ,]$dossier_recu)/ table(df[df$territoire == "GAM" ,]$dossier_recu)

  # Combinez les données en un data frame
  df <- data.frame(
    year = as.numeric(names(counts_gam)),
    Grenoble_Metropole = as.numeric(counts_gam),
    Gresivaudan = as.numeric(counts_g),
    Pays_Voironnais = as.numeric(counts_pv))

  # Transformez les données en format long
  df_long <- pivot_longer(df, cols = -year, names_to = "Territoire", values_to = "Taux_majorees")

  plot <- ggplot(df_long, aes(x = year, y = Taux_majorees, color = Territoire)) +
    geom_line() +
    labs(title = "Évolution du taux de primes majorées par an",
         x = "Année",
         y = "Taux de primes majorées") +
    scale_color_manual(values = c("Grenoble_Metropole" = "blue", "Gresivaudan" = "red", "Pays_Voironnais" = "green")) +
    theme_minimal() +
    theme(legend.position = "topleft")
  # Convertir l'objet ggplot en plotly
  plotly_plot <- ggplotly(plot, tooltip = c("x", "y", "group"))
  plotly_plot

}

evo_revenus <- function(territoire_name){
  df <- df %>%
    filter(revenus != "Pas de réponse")
  plot <- df[!is.na(df$revenus),] %>%
    group_by(dossier_recu, revenus) %>%
    summarise(n = n()) %>%
   mutate(percentage = n / sum(n) * 100) %>% # pour avoir le graph en pourcent
    ggplot(aes(x = dossier_recu, y = percentage, group = revenus, fill = revenus, )) +
    geom_area(stat = "identity") + guides(fill="none")
  # Convertir l'objet ggplot en plotly
  plotly_plot <- ggplotly(plot, tooltip = c("x", "y", "group"))

  plot <- df[!is.na(df$revenus),] %>%
    group_by(dossier_recu, revenus) %>%
    summarise(n = n()) %>%
    ggplot(aes(x = dossier_recu, y = n, group = revenus, fill = revenus, )) +
    geom_area(stat = "identity") 
  # Convertir l'objet ggplot en plotly
  plotly_plot2 <- ggplotly(plot, tooltip = c("x", "y", "group"))

  fig <- subplot(plotly_plot, plotly_plot2, nrows = 1, shareX = TRUE) %>% 
    layout(title = 'Evolution de la demande de prime par tranche de revenus')
  
  fig
}

aide_terr <- function(){
  plot <- ggplot(data, aes(x=territoire, y=montant_aide, fill = territoire)) +
    geom_boxplot()+
    scale_fill_manual(values=c("green", "red", "blue"))
  plotly_plot <- ggplotly(plot)
  plotly_plot
}

somme_des_aides <- function(){
  df <- data[data$transfert_facture > "2016-01-01" & data$transfert_facture < "2024-01-01" & !is.na(data$transfert_facture),]
  df$transfert_facture <- format(df$transfert_facture, "%Y")
  plot <- df %>%
    filter(!(is.na(montant_aide))) %>%
    group_by(transfert_facture, territoire) %>%
    summarise(sum = sum(montant_aide)) %>%
    ggplot(aes(x = transfert_facture, y =  sum, group = territoire, color = territoire)) +
    geom_point() + geom_line() + labs(title = "Évolution de la somme du montant des primes par an",
           x = "Année",
           y = "Somme des primes") +
    scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green")) + guides(color = "none")
  # Convertir l'objet ggplot en plotly
  plotly_plot <- ggplotly(plot, tooltip = c("x", "y", "group"))
  
  plot <- df %>%
    filter(!(is.na(montant_aide))) %>%
    group_by(transfert_facture, territoire) %>%
    summarise(sum = sum(montant_aide)) %>%
    group_by(territoire) %>%
    mutate(cs = cumsum(sum)) %>%
    ggplot(aes(x = transfert_facture, y =  cs, group = territoire, color = territoire)) +
    geom_point() + geom_line() + labs(x = "Année", y = "Somme des primes") +
    scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
  # Convertir l'objet ggplot en plotly
  plotly_plot2 <- ggplotly(plot, tooltip = c("x", "y", "group"))
  fig <- subplot(plotly_plot, plotly_plot2, nrows = 1, shareX = TRUE)
  
  fig
} 


#### Modes d'usages :

changement_app <- function(){
  p1 <- ggplotly(ggplot(data, aes_string(x = "type_ancien_appareil")) + geom_bar(position = "stack")  + 
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  p2 <- ggplotly(ggplot(data, aes_string(x = "nouveau_materiel")) + geom_bar(position = "stack") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  p3 <- ggplotly(ggplot(data, aes_string(x = "type_ancien_appareil", fill = "nouveau_materiel")) + geom_bar(position = "stack") +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  fig <- subplot(p1, p2, p3, nrows = 1, shareX = FALSE)
  fig
}

changement_usage <- function(){
  p1 <- ggplotly(ggplot(data, aes_string(x = "usage_ancien_materiel")) + geom_bar(position = "stack") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  p2 <- ggplotly(ggplot(data, aes_string(x = "usage_nouveau_materiel")) + geom_bar(position = "stack") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  p3 <- ggplotly(ggplot(data, aes_string(x = "usage_ancien_materiel", fill = "usage_nouveau_materiel")) + geom_bar(position = "stack") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)))
  fig <- subplot(p1, p2, p3, nrows = 1, shareX = FALSE)
  fig
  
}

evo_combustible <- function(){
  plot <- df %>%
    group_by(dossier_recu, type_combustible_nouveau_materiel) %>%
    summarise(n = n())  %>%
    filter(type_combustible_nouveau_materiel %in% c("Bûche", "Granulés")) %>%
    ggplot(aes(x = dossier_recu, y =  n, group = type_combustible_nouveau_materiel, color = type_combustible_nouveau_materiel)) +
    geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
                                      x = "Année",
                                      y = "Nombre de primes majorées") + guides(color="none")
  p1 <- ggplotly(plot, tooltip = c("x", "y", "group"))
  plot <- df %>%
    group_by(dossier_recu, type_combustible_nouveau_materiel) %>%
    summarise(n = n()) %>%
    mutate(percentage = n / sum(n) * 100) %>% 
    filter(type_combustible_nouveau_materiel %in% c("Bûche", "Granulés")) %>%
    ggplot(aes(x = dossier_recu, y =  percentage, group = type_combustible_nouveau_materiel, color = type_combustible_nouveau_materiel)) +
    geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
                                      x = "Année",
                                      y = "Nombre de primes majorées")
  p2 <- ggplotly(plot, tooltip = c("x", "y", "group"))
  fig <- subplot(p1, p2, nrows = 1, shareX = FALSE)
  fig
}


transfo <- function(qt, unite, type){
  if( is.na(qt) || is.na(unite) || is.na(type)) return(NA)
  qt = as.numeric(qt)
  if(type == "Bûche"){
    if(unite %in% c("Stères", "Mètre cube (M3)")){
      return(qt)
    } # à verif
  }
  else if(type == "Bois de récupération"){
    if(unite %in% c("Stères")) return(qt)
  }
  else if(type == "Granulés / Pellets"){
    if(unite %in% c("Stères", "Mètre cube (M3)")) return(qt)
    else if(unite %in% c("Tonnes")) return( qt * 4800 /1500)
    else if(unite == "Sacs") return( (qt *15 * 4.8) /1500)
  }
  
  return(NA)
}

evo_conso <- function(){
  eq_stere = c()
  for(i in 1:dim(enquete)[1]){
    eq_stere = c(eq_stere,transfo(enquete[i,"quelle_quantite_de_bois_avez_vous_utilise_lhiver_dernier_avec_votre_nouvel_appareil"], 
                                  enquete[i, "le_chiffre_de_la_question_precedente_concerne"], 
                                  enquete[i, "combustible_appareil_actuel"]))
  }
  eq_stere = na.omit(eq_stere)
  eq_stere2 = as.numeric(na.omit(data$equivalent_steres))
  eq_stere2 = eq_stere2[which(eq_stere2 >0 & eq_stere2 < 100)]
  eq_st = data.frame( date = c(rep("Ancien appareil", length(eq_stere2)), rep("Nouvel appareil", length(eq_stere))),  eq = c(eq_stere2, eq_stere) )
  plot <- ggplot(eq_st, aes(x=date, y=eq, fill = date)) +
    geom_boxplot() + ylim(-1,20) + ylab("Équivalent stère") + xlab("")
  
  grid.arrange(tableGrob(data.frame(Avant = round(c(summary(eq_stere2), var(eq_stere2)),2),
                                    Après = round(c(summary(eq_stere), var(eq_stere)),2),
                                    row.names = c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum", "variance"))),
               plot, nrow = 1)

}
