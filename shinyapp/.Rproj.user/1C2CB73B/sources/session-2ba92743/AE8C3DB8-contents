---
title: "test communes"
author: "Gabriel Macé"
date: "2024-06-14"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE, include = FALSE)
```

Données forêts :
SIDDT : (2013/2019) : part de la superficie/ ha, fermée /ouverte,conifères /feuillus/mixtes/ sans couvert / lande / formation hebarcée/ peupleraie
Sylviculture

https://foret.ign.fr/catalogue/649adf3b99b2a690a04ef2c7 : conifères /feuillus/mixtes/ sans couvert : 2023

Forêts publiques / privées

Producteurs / communes ?

```{r, include=FALSE}
library(readxl)
library(writexl)
library(stringr)
library(tidyr)
library(sf)
library(dplyr)
library(stats)
library(ggplot2)
library(stats)
library(reshape2)
library(corrplot)
library(fastDummies)
library(plotly)
```

```{r}
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```

```{r}
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$insee_com %in% c("38453","38278", "38526", "38194", "38118", "38013", "38248", "38450", "38236", "38412", "38405", "38442", "38446", "38378"),]
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]


binaire <- read_excel("../data/2_Travail/export_questionnaire_binaire.xlsx")
binaire <- binaire[binaire$`N° dossier` %in% data$N..dossier,]
binaire_buche <- binaire[,c(1,31,50:54)]
binaire_buche <- binaire_buche[binaire_buche$`Type combustible nouveau materiel` == "Bûche",]
binaire_buche <- left_join(binaire_buche, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire_buche <- binaire_buche[!duplicated(binaire_buche$`N° dossier`),c(2:7)]
binaire <- binaire[,c(1,50:54)]
binaire <- left_join(binaire, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire <- binaire[!duplicated(binaire$`N° dossier`),c(2:7)]


```


```{r}
data_acp <- data[,c(1,43)] %>% group_by(insee_com) %>% count()

#quanti = c("cout_total_TTC", "montant_aide","cout_appareil") # , "équivalent_steres"
quali = c("Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration"
          )
#  "Année.installation",
for(col in quali){
df_long <- data[,c(col, "insee_com")]
df_long <- dummy_cols(df_long, select_columns = col, remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, df_binary, by = "insee_com")
}



df <- data[,c("insee_com","cout_total_TTC")] %>% group_by(`insee_com`) %>% summarise(cout_total_TTC = mean(na.omit(cout_total_TTC)))
data_acp <- left_join(data_acp, df, by = "insee_com")

binaire2 <- binaire %>% group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, binaire2, by = "insee_com")

for(i in 3:dim(data_acp)[2]){
  data_acp[,i] = data_acp[,i] / data_acp$n
}
terr = data[,c("Territoire","insee_com", "adresse_ville")]
terr = terr[!duplicated(terr$insee_com),]
data_acp <- left_join(data_acp, terr, by = "insee_com")
```




```{r, include=FALSE}
comm <- read.csv("../data/siddt.csv", sep = ";", skip = 2)[-c(124:130),c(1,2, 3,4,6)]
comm2 <- read.csv("../data/siddt2.csv", sep = ";", skip = 2)[-c(124:130),c(1, 3:5)]
logement = read.csv("../data/logements_2020.csv", sep =";", skip= 2)[-c(124:130),c(1,3)]
objectifs_communes <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[1:123,1:4]
oc <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[124:239,c(2,4)]
objectifs_communes <- left_join(objectifs_communes, oc, by = "id_comm")
objectifs_communes$id_comm = as.character(objectifs_communes$id_comm)
objectifs_communes = objectifs_communes[,c(2,4,5)]
names(objectifs_communes)= c("insee_com", "objectifs_2022", "changement_2023")
objectifs_communes$changement_2023 = abs(objectifs_communes$changement_2023)
objectifs_communes[is.na(objectifs_communes$changement_2023), "changement_2023"] <- 0
revenus_communes <- read_xlsx("../data/revenu_communes_insee.xlsx", skip = 5, col_names = TRUE)
revenus_communes <- revenus_communes[revenus_communes$CODGEO %in% data$insee_com,]
revenus_communes = revenus_communes[, c(1, 3:5)]
names(revenus_communes) = c("insee_com", "nb_ménages_fiscaux", "nb_personnes_menages_fiscaux", "mediane_niveau_vie")
types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome peu dense", "rural autonome très peu dense", "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
surf_bois <- read_excel("../data/surface_boisee_off_2023.xlsx", sheet = "données")
surf_bois = surf_bois[surf_bois$`INSEE commune` %in% data$insee_com,c("INSEE commune", "Surface commune", "feuillus", "mixtes")]
```


```{r}
count <- data %>%
  group_by(insee_com) %>%
  count()
fo <- data[data$Type.Ancien.appareil != "Foyer ouvert",] %>%
  group_by(insee_com) %>%
  count()
buche <- data[data$Type.combustible.nouveau.materiel == "Bûche",] %>%
  group_by(insee_com) %>%
  count()
maj <- data[data$majoration == "M",] %>% group_by(insee_com) %>% count()
names(comm) <- c("communes.depcom","commune", "superficie_foret", "taux_forets", "évolution_nb_logements")
data_test = left_join(count, comm, by = join_by("insee_com" == "communes.depcom"))
names(comm2) <- c("communes.depcom", "Densité_pop", "Part_résidences_principales_loc", "part_maisons")
data_test <- data_test %>% left_join(comm2, by = join_by("insee_com" == "communes.depcom"))
names(logement) = c("insee_com", "nb_maisons_rp_2020")
data_test <- data_test %>% left_join(logement, by = "insee_com")
data_test <- data_test %>% left_join(types_communes, by = "insee_com")
data_test <- data_test %>% left_join(objectifs_communes, by = "insee_com")
data_test <- data_test %>% left_join(revenus_communes, by = "insee_com")
data_test <- na.omit(data_test)
data_test[, "taux_dossiers_habitant"] = data_test$n / as.numeric(data_test$nb_personnes_menages_fiscaux)
data_test[, "taux_changement"] = data_test$changement_2023 / data_test$objectifs_2022
data_test[, "objectifs_2022_par_maison"] = data_test$objectifs_2022 / data_test$nb_maisons_rp_2020
data_test[, "taux_feuillus"] = surf_bois$feuillus / surf_bois$`Surface commune`
data_test[, "taux_feuillus_mixte"] = (surf_bois$feuillus + surf_bois$mixtes) / surf_bois$`Surface commune`
```

```{r}
data_acp <- data_acp[,setdiff(names(data_acp),c("Type.Ancien.appareil_Pas de réponse", "Usage.ancien.matériel_Pas de réponse", "Nouveau.matériel_Pas de réponse", "Type.combustible.nouveau.materiel_autre","Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", "Usage.nouveau.matériel_Pas de réponse", "majoration_NA"
                                                ,"Nouveau.matériel_Insert / foyer fermé", "Type.combustible.nouveau.materiel_Granulés", "majoration_NM"
))]

# variable devenues binaires :
# ,"Nouveau.matériel_Insert / foyer fermé", "Type.combustible.nouveau.materiel_Granulés", "majoration_NM"
for(col in setdiff(names(data_acp), c("insee_com","Territoire", "adresse_ville"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
for(col in setdiff(names(data_test), c("insee_com","commune","type_commune"))){
  data_test[,col] <- as.numeric(data_test %>% pull(col))
}
data_acp <- data_acp[data_acp$insee_com %in% data_test$insee_com,]
data_acp = data_acp[data_acp$n >= 10,]
data_test <- data_test[data_test$insee_com %in% data_acp$insee_com,]
df = left_join(data_acp, data_test[,setdiff(names(data_test),c("n","commune"))], by = "insee_com")
```


```{r}
co = c()
var1 = c()
var2 = c()
p_value_correlation = c()
for(q in setdiff(names(data_acp), c("insee_com","Territoire","n", "adresse_ville"))){
  for(q2 in setdiff(names(data_test), c("insee_com", "commune", "Territoire", "type_commune"))){
      ct = cor.test(as.numeric(df %>% pull(q)), as.numeric(df %>% pull(q2)))
      p_value_correlation = c(p_value_correlation, ct$p.value)
      co = c(co, ct$estimate)
      var1 = c(var1, q)
      var2 = c(var2, q2)
    }
}
res_corr = data.frame(q1 = var1, q2 = var2, correlation = round(co,3), p_value_corr = p.adjust(p_value_correlation, method = "BH", n = length(p_value_correlation)))
res_corr
```
```{r}
res_corr[res_corr$correlation >0.45,]
```

ENLEVER LES DOUBLONS
# trouver des outliers :
```{r}
# local outlier factor
library(dbscan)
X = scale(na.omit(data_test[,setdiff(names(data_test),c("insee_com", "commune", "Territoire", "type_commune", "nb_ménages_fiscaux","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022", "surface_feuillus_mixte", "taux_forets"))]))

lof = lof(X, minPts = 10) # minPts = nombre de voisins aux quels chaque point sera connecté

plot(sort(lof))
abline(h= 1.5, col = "red")
na.omit(data_test)[which(lof > 1.5),"commune"]

```


```{r}
# Isolation Forest
library(isotree)
X = scale(na.omit(data_test[,setdiff(names(data_test),c("insee_com", "commune", "Territoire", "type_commune", "nb_ménages_fiscaux","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022", "surface_feuillus_mixte", "taux_forets"))]))
isf = isolation.forest(X, ntrees = 50, output_score = TRUE) # 500 le mieux, après ne s'améliore pas
summary(isf$scores)
plot(sort(isf$scores))
abline(h= 0.50, col = "red")
na.omit(data_test)[which(isf$scores > 0.5),"commune"]
```




```{r}
# local outlier factor
X = scale(data_acp[,setdiff(names(data_acp), c("insee_com","Territoire","n", "adresse_ville"))])

lof = lof(X, minPts = 10) # minPts = nombre de voisins aux quels chaque point sera connecté

plot(sort(lof))
abline(h= 1.5, col = "red")
data_acp[which(lof > 1.5),]$adresse_ville
```
```{r}
# Isolation Forest
X = scale(data_acp[,setdiff(names(data_acp), c("insee_com","Territoire","n", "adresse_ville"))])
isf = isolation.forest(X, ntrees = 20, output_score = TRUE) # 500 le mieux, après ne s'améliore pas
summary(isf$scores)
plot(sort(isf$scores))
abline(h= 0.55, col = "red")
data_acp[which(isf$scores > 0.55),]$adresse_ville
```
 
```{r}
for(m in c("ward.D", "ward.D2", "single", "complete", "average" , "mcquitty" , "median", "centroid")){
plot(hclust(dist(scale(data_test[,setdiff(names(data_test), c("insee_com", "commune", "Territoire"))])), method = m), main = m)
}
```

```{r, include = TRUE}
hc = hclust(dist(scale(data_test[,setdiff(names(data_test), c("insee_com", "commune", "Territoire"))])))
plot(hc, main = "Clusterin ascendant hiérarchique")
rect.hclust(hc,k=5)
```

36 : Grenoble : Grande population, densité, part résidences principales en location, faible part maisons, fort taux de changement, faible niveau de vie, peu de dossier par hab

123 : Chamrousse : gros taux objectifs de changement par maison mais 0 changement,  faible part maisons, peu de maisons et de personnes, faible niveau de vie, fort taux  foyers ouverts ,et fort taux de majoration

78 : Plateau-des-Petites-Roches -> fort : nombre de dossiers, taux de dossiers par habitants, taux de changement

29 : Le Haut-Bréda : grande superficie de forêts, baisse du nb logements, faible niveau de vie

98 : Sarcenas : fort taux de forets, baisse du nb logements, peu d'habitants, fort niveau de vie, fort taux de dossiers par habitants, et changement d'appareils / objectifs

```{r}
for(v in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
  boxplot(data_test[,v] , main = v)
  points(x = 1, y = data_test[36,v], col = "blue")
  points(x = 1, y = data_test[123,v], col = "red")
  points(x = 1, y = data_test[78,v], col = "green")
  points(x = 1, y = data_test[29,v], col = "pink")
  points(x = 1, y = data_test[98,v], col = "yellow")
}
```
# Clustering :

5 groupes, dont 2 avec des outliers.
```{r, include = TRUE}
# Créez une variable de regroupement en utilisant kmeans
set.seed(23)
res.km <- kmeans(scale(na.omit(data_test[,setdiff(names(data_test), c("insee_com", "commune", "Territoire"))])), centers = 5, nstart = 25)# Créez 3 groupes de variables (centers = 3)
grp <- as.factor(res.km$cluster)
table(na.omit(data_test)$Territoire, grp)

```
Les groupes ne correspondents pas aux territoires


```{r}
corre = cor(na.omit(data_test[,setdiff(names(data_test), c("insee_com", "commune", "Territoire"))]))
heatmap(corre[1:9, 1:9],Colv = NA, Rowv = NA, scale="column")
heatmap(corre[1:9, 10:18],Colv = NA, Rowv = NA, scale="column")
heatmap(corre[10:18, 1:9],Colv = NA, Rowv = NA, scale="column")
heatmap(corre[10:18, 10:18],Colv = NA, Rowv = NA, scale="column")
heatmap(corre,Colv = NA, Rowv = NA, scale="column", )
```


```{r}
for(co in list(corre[1:9,1:9],corre[1:9,10:19],corre[10:19,1:9],corre[10:19,10:19])){
c2 <- melt(co)
p <- ggplot(data = c2, aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
print(p)
}
ggplot(data = melt(corre), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```
Variable qui se ressemblent fortement :
Densité pop / nb_menages_fiscaux / nb_personnes_menages_fiscaux : garder densité pop
Part_résidences_principales_loc / part_maisons : garder part maison
nb_maisons_2020 / objectifs_2022 / changment_2023 et un peu nb dossier : enlever chgment 2023, ratio objectif / nb_maison, garder nb maison
3 taux de dossiers : maisons / menages / habitants : garder par habitants
taux de forets entre eux -> feuillus


```{r}
ggplot(data = melt(corre[-c(14:16),c(1, 14:16)]), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```


**Tests corrélation variables quantitatives**

```{r}
# lm : H0 : X n'a pas d'effet sur Y
#library(car)
p_value_correlation = c()
co = c()
p_value_lm = c()
var1 = c()
var2 = c()
r2 = c()
quanti2 = c()
for(q in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
  quanti2 = c(quanti2, q)
  for(q2 in setdiff(setdiff(names(data_test), c("insee_com", "commune", "Territoire")), quanti2)){
    if(q != q2){
      df = drop_na(data_test, c(q, q2))
      ct = cor.test(as.numeric(df %>% pull(q)), as.numeric(df %>% pull(q2)))
      p_value_correlation = c(p_value_correlation, ct$p.value)
      p_value_lm = c(p_value_lm,summary(lm(df %>% pull(q2)~df %>% pull(q)))$coefficients["df %>% pull(q)", "Pr(>|t|)"]) # q explique q2
      r2 =  c(r2,summary(lm(df %>% pull(q2)~df %>% pull(q)))$r.squared)
      co = c(co, ct$estimate)
      var1 = c(var1, q)
      var2 = c(var2, q2)
    }
  }
}
res_corr = data.frame(q1 = var1, q2 = var2, correlation = round(co,3), p_value_corr = p.adjust(p_value_correlation, method = "BH", n = length(p_value_correlation)), r2 = round(r2,3), p_value_lm_ajustée = p.adjust(p_value_lm, method = "BH", n = length(p_value_lm)))
res_corr
# print("vif kwh : ") # à quelle point c'est facile de prédire cette variable part régression linéaire
# print(vif(lm(kwh~.-kwh, data = data[,quanti])))
# print("vif Surf.chauff.logement : ")
# print(vif(lm(Surf.chauff.logement~., data = data[,quanti])))
# print("vif Nb.pers.ménage : ")
# print(vif(lm(Nb.pers.ménage~., data = data[,quanti])))
# print("vif count_total_TTC : ")
# print(vif(lm(cout_total_TTC~., data = data[,quanti])))
# print(" vif montant_aide : ")
# print(vif(lm(montant_aide~., data = data[,quanti])))
```

```{r}
res_corr[abs(res_corr$correlation) > 0.5,]
```

```{r}
res_corr[res_corr$r2 > 0.5,]
```

```{r}
res_corr[res_corr$p_value_lm_ajustée >= 0.05,]
```

```{r}
res_corr[res_corr$q1 == "taux_dossiers_habitant" | res_corr$q2 == "taux_dossiers_habitant",]
```

```{r}
res_corr[res_corr$p_value_lm_ajustée < 0.05 & (res_corr$q1 == "n" | res_corr$q2 == "n"),]
```

```{r}

```

```{r}

```


```{r}
# lm : H0 : X n'a pas d'effet sur Y
#library(car)
p_value_correlation = c()
co = c()
p_value_lm = c()
var1 = c()
var2 = c()
r2 = c()
quanti2 = c()
for(q in setdiff(names(data_test), c("insee_com", "commune", "Territoire", "nb_ménages_fiscaux","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022", "surface_feuillus_mixte", "taux_forets"))){
  quanti2 = c(quanti2, q)
  for(q2 in setdiff(setdiff(names(data_test), c("insee_com", "commune", "Territoire", "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")), quanti2)){
    if(q != q2){
      df = drop_na(data_test, c(q, q2))
      ct = cor.test(as.numeric(df %>% pull(q)), as.numeric(df %>% pull(q2)))
      p_value_correlation = c(p_value_correlation, ct$p.value)
      p_value_lm = c(p_value_lm,summary(lm(df %>% pull(q2)~df %>% pull(q)))$coefficients["df %>% pull(q)", "Pr(>|t|)"]) # q explique q2
      r2 =  c(r2,summary(lm(df %>% pull(q2)~df %>% pull(q)))$r.squared)
      co = c(co, ct$estimate)
      var1 = c(var1, q)
      var2 = c(var2, q2)
    }
  }
}
res_corr = data.frame(q1 = var1, q2 = var2, correlation = round(co,3), p_value_corr = p.adjust(p_value_correlation, method = "BH", n = length(p_value_correlation)), r2 = round(r2,3), p_value_lm_ajustée = p.adjust(p_value_lm, method = "BH", n = length(p_value_lm)))
res_corr
```


```{r}
res_corr[abs(res_corr$correlation) > 0.5,]
```

```{r}
res_corr[res_corr$r2 > 0.5,]
```

```{r}
ggplot(data = melt(corre[setdiff(names(data_test), c("insee_com", "commune", "Territoire", "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")),setdiff(names(data_test), c("insee_com", "commune", "Territoire", "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022"))]), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```

```{r}
# sans les doublons
rl = lm(taux_dossiers_habitant~ superficie_foret + taux_forets + évolution_nb_logements + Densité_pop + part_maisons + nb_maisons_rp_2020 + mediane_niveau_vie + taux_foyers_ouverts + taux_buches_nouveau_mat + taux_majoration + taux_changement + objectifs_2022_par_maison, data = data_test)
```

```{r}
s = summary(rl)
s
s$r.squared
```

```{r}
rl = lm(taux_dossiers_habitant~. -insee_com - commune - Territoire - taux_dossiers_menages - n - taux_dossiers_maisons, data = data_test)
s = summary(rl)
s$r.squared
# , "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")
```

```{r}
tdh = data_test %>% pull("taux_dossiers_habitant")
for(v in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
vd = data_test %>% pull(v) 
rl = lm(tdh~vd)
s = summary(rl)
print(v)
print(s$r.squared)
}
# , "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")
```

```{r}
# sans les r² < 0.1
rl = lm(taux_dossiers_habitant~ superficie_foret + taux_forets + Densité_pop + part_maisons + nb_maisons_rp_2020 + mediane_niveau_vie + taux_changement , data = data_test)
summary(rl)$r.squared
```

```{r}
library(performance)
check_collinearity(rl)
```
