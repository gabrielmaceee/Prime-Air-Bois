---
title: "AFDM"
author: "Gabriel Macé"
date: "2024-05-24"
output: html_document
---


Régression linéaire / logistique ancien / nouveau

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE)
```

```{r}
library(FactoMineR)
library(factoextra)
library(readxl)
library(tidyr)
library(dplyr)
library(stats)
library(missMDA)
library(corrplot)
library(ggplot2)
library(plotly)
library(reshape2)
library(stringr)
library(sf)
```
Récuperer les donnnées des serveurs :
```{r}
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```


```{r}
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
# data <- data[!is.na(data$dossier_reçu),]
data <- data[!is.na(data$dossier_reçu),]
#data <- data[data$dossier_reçu > "2022-03-01",]

# binaire <- read_excel("../data/2_Travail/export_questionnaire_binaire.xlsx")
# binaire <- binaire[binaire$`N° dossier` %in% data$N..dossier,]
# binaire <- binaire[,c(1,50:54)]
# binaire <- binaire[!duplicated(binaire$`N° dossier`),c(1,2:6)]
# # regrouper certaines modalités de la raison du changement d'appareil
# binaire$`Qualité_air` <- binaire$`Qualité air de mon logement` + binaire$`Qualité de l'air extérieur`
# binaire[binaire$`Qualité_air` == 2,]$`Qualité_air` <- 1
# binaire$économiser <- binaire$`Économiser de l'argent` + binaire$`Économiser du bois/énergie`
# binaire[binaire$économiser == 2,]$économiser <- 1
# binaire <- binaire[, c(1,5,7:8)]

types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome très peu dense", "rural autonome peu dense",  "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
#data <- left_join(data, binaire, by = join_by("N..dossier" == "N° dossier"))
data <- left_join(data, types_communes, by = "insee_com")

data$Revenus <- factor(data$Revenus, levels = rev(c("Pas de réponse", "Moins de 20 000 €", "20 000 à 30 000 €", "30 000 à 40 000 €", "40 000 à 50 000 €", "50 000 à 60 000 €", "60 000 à 70 000 €", "70 000 à 80 000 €", "80 000 à 90 000 €", "Plus de 100 000 €")))

data$Usage.ancien.matériel <- factor(data$Usage.ancien.matériel, levels = c("Chauffage principal", "Chauffage d'appoint", "Plaisir / agrément", "Pas de réponse"))
data$Usage.nouveau.matériel <- factor(data$Usage.nouveau.matériel, levels = c("Chauffage principal", "Chauffage d'appoint", "Plaisir / agrément", "Pas de réponse"))

data$Freq.utilisation.période.chauffe <- factor(data$Freq.utilisation.période.chauffe, levels = c("Tous les jours", "3 à 4 jours / semaine", "1 à 2 jours / semaine", "1 à 3 jours / mois", "moins souvent", "Jamais", "Pas de réponse"))

data$Durée.séchage.bois <- factor(data$Durée.séchage.bois, levels =c("<1an", "1-2 ans", "> 2 ans", "Ne sait pas", "Pas de réponse"))

data <- data %>% filter(!data$Nouveau.matériel == "Pas de réponse")

data[data$Type.Ancien.appareil == "Poêle" & data$Type.combustible %in% c("Pas de réponse", 'Autre (détails dans colonne "Type combustible autre")'),"Type.combustible"] <- "à enlever"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel %in% c("Pas de réponse", "autre", "Bûche, autre"),"Type.combustible"] <- "à enlever"
data <- data %>% filter(!data$Type.combustible == "à enlever" )
data <- data %>% filter(!data$Type.combustible.nouveau.materiel == "à enlever" )

data[data$Type.Ancien.appareil  == "Poêle" & data$Type.combustible %in% c("Bûche", "Bois de récup"),]$Type.Ancien.appareil <- "Poêle buche"
data[data$Type.Ancien.appareil  == "Poêle" & data$Type.combustible == "Granulés",]$Type.Ancien.appareil <- "Poêle granulés"

data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Bûche",]$Nouveau.matériel <- "Poêle bûche"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Bûche, Granulés",]$Nouveau.matériel <- "Poêle mixte"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Granulés",]$Nouveau.matériel <- "Poêle granulés"
```


```{r}
library(fastDummies)
 df_long <- data[, c("N..dossier", "Stockage.bois" )] %>%
    separate_rows("Stockage.bois", sep = c(", "))
  df_long <- dummy_cols(df_long, select_columns = "Stockage.bois", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
  df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
  names = c("Stockage.bois_A l'intérieur", "Stockage.bois_Pas de réponse", "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris")
  names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier", "Stockage.bois_A l'intérieur", "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris")]
data <- data %>% left_join(df_binary, by = "N..dossier")


df_long <- data[, c("N..dossier", "Approvisionnement" )] %>%
    separate_rows("Approvisionnement", sep = c(", "))
df_long <- dummy_cols(df_long, select_columns = "Approvisionnement", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
names = c("autre (colonne Questionnaire.Appro autre)", "Pas de réponse",   "personnel / gratuit", "Point de vente non spécialisé", "Producteur indépendant")
names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier","personnel / gratuit", "Point de vente non spécialisé","Producteur indépendant")]
data <- data %>% left_join(df_binary, by = "N..dossier")


df_long <- data[, c("N..dossier", "Ramonage.installation" )] %>%
    separate_rows("Ramonage.installation", sep = c(", "))
df_long <- dummy_cols(df_long, select_columns = "Ramonage.installation", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
names = c(" Pas de réponse", "un professionnel", "vous même")
names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier","un professionnel", "vous même")]
data <- data %>% left_join(df_binary, by = "N..dossier")
```



```{r}
for(cate in c("Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e")){
  data[,cate] <- rep(0, dim(data)[1])
  data[data$Sit.pro.conjoint == cate | data$Sit.pro.demandeur == cate, cate] <- 1
}
```




```{r}
# a_enlever <-c("Classe.énergétique.logement", "Type.combustible.autre", "Qtté.bois.consommée", "Qtté.bois.unité", "Appro.autre", "Origine.bois", "Fréquence.ramonage.autre", "Type.combustible.nouveau.matériel.autre", "Fréquence.utilisation.période.de.chauffe.nouveau.matériel", "Motivation.autre", "Connaissance.aide.site.internet", "Connaissance.aide.autre", "insee_com", "kwh", "transfert_facture","dossier_reçu")
# a_enlever = c(a_enlever, "équivalent_steres", "Nature.logement", "Occupation.logement", "Stockage.bois", "Type.combustible", "adresse_ville", "Motivation.changement.appareil", "Connaissance.aide", "Travaux.iso.depuis.2005", "Période.utilisation", "Sit.pro.demandeur", "Sit.pro.conjoint", "Surf.chauff.logement", "Fréquence.ramonage", "Ramonage.installation","Type.de.bois", "cout_appareil")
# #"Année.installation",  "Revenus",  "montant_aide")
# # faire un afc pour motivation changement appareil ? 
# data_afmd <- data[,setdiff(names(data), a_enlever)]


utilisation = c("Type.Ancien.appareil", "Usage.ancien.matériel", "Nouveau.matériel",  "Usage.nouveau.matériel","cout_total_TTC", "type_commune", "Territoire", "montant_aide", 
                # "économiser", "Gagner en confort/chaleur", "Qualité_air", 
                # variable ajoutées après : 
                 "Revenus", "Nb.pers.ménage", "Année.installation", "Durée.séchage.bois", "cluster_com",
               "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e"
                #"Sit.pro.demandeur"#, "Sit.pro.conjoint", "Type.combustible.nouveau.materiel",
              #,"refusé"
              # , "dossier_reçu"
              ,"personnel / gratuit", "Point de vente non spécialisé","Producteur indépendant" # "Approvisionnement",
              , "Age", "majoration", "Freq.utilisation.période.chauffe"
              , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris", # "Stockage.bois", 
              "un professionnel", "vous même" #, "Ramonage.installation"
                )

usage <- c("Type.Ancien.appareil", "Usage.ancien.matériel", "Nouveau.matériel",  "Usage.nouveau.matériel","cout_total_TTC", "Année.installation", "Durée.séchage.bois", "personnel / gratuit", "Point de vente non spécialisé","Producteur indépendant", "Freq.utilisation.période.chauffe"
              , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris",  "un professionnel", "vous même")
  
socio_pro <-c("type_commune", "Territoire", "montant_aide", "Revenus", "Nb.pers.ménage",  "cluster_com", "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e", "Age", "majoration")

data_afmd <- na.omit(data[,c("N..dossier",utilisation)])# tranche de revenu, catégorie sp 2,
# supprimer les pas de réponse dans nouvel app et type de combustible poêle
# poele -> buche, granules, mixte ancien nouveau
# enlever majoration, freq util car font doublons avec revenus et le type d'appareil / usage 
# trouver une representation ACP : var / ind
# ajouter la freq / pop totale dans les graphs

setdiff(c(usage, socio_pro), utilisation)
```

```{r}
# data_sans_na <- imputeFAMD(data_afmd, ncp = 10)
```

```{r}
# c = 0
# for(i in 1:dim(data)[1]){
#   for(v in setdiff(utilisation, c("cluster_com", "cout_total_TTC","montant_aide", "Nb.pers.ménage",
#                     "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e",
#                     "personnel / gratuit", "Point de vente non spécialisé","Producteur indépendant"
#                     , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris",
#                     "un professionnel", "vous même", "majoration", "type_commune"
#                     )
#                    
#                    )){
#     if(data[i,v] == "Pas de réponse"){
#       c = c + 1
#       break
#     }
#   }
# }
# print(c)
# 1972
```

```{r}
for(v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  data_afmd[,v] <- as.numeric(data_afmd %>% pull (v))
}
```


```{r}
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  data_afmd[,v] <- as.factor(data_afmd %>% pull (v))
}
```


# amélioration AFDM : centrer réduire, sélectionner les variables, faire plusieurs ACP selon une variable
```{r}
res.afdm<- FAMD(data_afmd[,-1], sup.var = c("Territoire", "montant_aide", "cluster_com", "type_commune", "Age", "majoration", "Freq.utilisation.période.chauffe"), graph = FALSE, ncp = 54)

```

```{r}
eig.val <- get_eigenvalue(res.afdm)
head(eig.val,100)
```

```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 2, nstart = 25) # dim 1 qui sépare
grp <- as.factor(res.km$cluster)
summary(grp)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster", geom = c("point"))

#data_afmd <- data_afmd[grp == "1",c("N..dossier",utilisation)]
#res.afdm<- FAMD(data_afmd, sup.var = c("Territoire", "montant_aide", "cluster_com", "type_commune", "Age", "majoration", "Freq.utilisation.période.chauffe"), graph = FALSE, ncp = 54)
```

A chaque fois un groupe de ~380 individus se démarque -> "Pas de réponse"

-> regarder par année et / ou supprimer
-> depend pas du temps -> supprimer

```{r}
# df <- data_afmd[data_afmd$dossier_reçu > "2016-01-01" & data_afmd$dossier_reçu < "2024-01-01" & !is.na(data_afmd$dossier_reçu) & grp=="1",]
# df$dossier_reçu <- format(df$dossier_reçu, "%Y")
# 
# df %>%
#   group_by(dossier_reçu, Territoire) %>%
#   summarise(n = n()) %>%
#   ggplot(aes(x = dossier_reçu, y =  n, group = Territoire, color = Territoire)) +
#   geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
#                                  x = "Année",
#                                  y = "Nombre de primes majorées") +
#   scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
# 
# df <- data_afmd[data_afmd$dossier_reçu > "2016-01-01" & data_afmd$dossier_reçu < "2024-01-01" & !is.na(data_afmd$dossier_reçu) & grp=="2",]
# df$dossier_reçu <- format(df$dossier_reçu, "%Y")
# 
# df %>%
#   group_by(dossier_reçu, Territoire) %>%
#   summarise(n = n()) %>%
#   ggplot(aes(x = dossier_reçu, y =  n, group = Territoire, color = Territoire)) +
#   geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
#                                  x = "Année",
#                                  y = "Nombre de primes majorées") +
#   scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
```




```{r}
#La fonction fviz_eig() ou fviz_screeplot() [factoextra] peut être utilisée pour visualiser les proportions de variances expliquées par les différents axes:
fviz_screeplot(res.afdm)
```


```{r}
var = get_famd_var(res.afdm)
corrplot(var$contrib[,1:20], is.corr = FALSE) 
corrplot(var$cos2[,1:20], is.corr = FALSE) # qualité de représentation
fviz_contrib(res.afdm, choice = "var", axes = c(1,2))
fviz_cos2(res.afdm, choice = "var", axes = c(1,2))
```


```{r}
fviz_contrib(res.afdm, choice = "var", axes = c(1:48), top = 30)
fviz_cos2(res.afdm, choice = "var", axes = c(1:48), top = 30)
```
-> plus forcément très pertinent à analyser avec la décomposition de certaines variables en binaires

```{r}
plot.FAMD(res.afdm,title="Graphe des individus et des modalités")
plot.FAMD(res.afdm,axes=c(1,2),choix='var',title="Graphe des variables")
fviz_famd_var(res.afdm, col.var = "bisque4", repel = TRUE )
plot.FAMD(res.afdm, choix='quanti',title="Cercle des corrélations")
```




```{r}
fviz_famd_ind(res.afdm, habillage = "Territoire", palette = c("green","red", "blue"), geom = c("point"))
# capv = en dernier donc se mettent au dessus des autres
```




## Clustering :
### Clustering ascendant hiérarchique : 

```{r}
hc <- hclust(dist(res.afdm$ind$coord), method = "ward.D")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 2))
fviz_famd_ind(res.afdm, habillage =  memb, label = c( "var"), palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)

hc <- hclust(dist(res.afdm$ind$coord), method = "ward.D2")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 2))
fviz_famd_ind(res.afdm, habillage = memb, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, label = c( "var"),)

```

### Avec 2 groupes :

```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 2, nstart = 25) # dim 1 qui sépare
grp <- as.factor(res.km$cluster)
summary(grp)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, axes = c(1,2), geom = "point") 

for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  print(v)
  t = table(grp, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2, "Pop de référence")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  print(round(t[1:3,- dim(t)[2]],2))
     plot(round(t[1:3,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp == 2, ] %>% pull(v)))
}
```



```{r}
# Extraire les données des variables et des individus
var_coord <- as.data.frame(res.afdm$quali.var$coord)
contrib = rowSums(res.afdm$quali.var$contrib)
cos2 = rowSums(res.afdm$quali.var$cos2)
var_coord = var_coord[contrib >95 & cos2 > 0.95,]
ind_coord <- as.data.frame(res.afdm$ind$coord)
ind_coord$cluster <- grp

# Créer le plot pour les variables
plot <- ggplot() + 
  # Points pour les individus colorés par clusters
  geom_point(data = ind_coord, aes(x = Dim.1, y = Dim.2, color = factor(cluster))) +
  # Textes pour les catégories des variables
  geom_text(data = var_coord, aes(x = Dim.1, y = Dim.2, label = rownames(var_coord)),
            color = "red", size = 3.5)  +
  scale_color_manual(values = c("#0073C2FF", "#EFC000FF")) +
  theme_minimal() +
  labs(title = "Biplot des Variables et des Individus",
       x = "Dim 1",
       y = "Dim 2")

print(plot)
# xlim et ylim
```


```{r}
library(clv)
# compute intercluster distances and intracluster diameters
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```
Séparation entre usage fort, granulés, poêle / foyer fermé, moins riches, plus majorés, plus employés, (moitié des agriculteurs), un peu plus de rurales
Vs 
usage appoint, bûches,  foyer ouvert / fermé, plus riches; moins majorés, plus cadres, un peu plus d'urbains

Retraités entre deux

#### Cartographie des clusters :

```{r, echo = FALSE}
# Get polygons communes data
sql <- "SELECT insee_com, nom_m AS nom_commune, the_geom 
        FROM bd_admin_express.geo_commune_2022
        WHERE insee_dep = '38'
		    ORDER BY 1"
layer_communes <- st_read(con, query = sql)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]

shp <- st_read(dsn = "../data/EPCI 2024_region.shp")
shp = shp[c(27, 175, 929),]
shp$ sociale <- c("CCLG", "GAM", "CAPV")
```

```{r}
data_afmd$grp = grp
```

```{r}
data_plot <- data_afmd %>% left_join(data[, c("N..dossier", "insee_com")], by = "N..dossier")
data_plot <- data_plot[!duplicated(data_plot$N..dossier),]
# data_plot <- data_plot %>% group_by(insee_com, grp) %>%    summarise(n = n()) %>%
#     mutate(percentage = n / sum(n) * 100)
data_plot <- data_plot %>% group_by(insee_com) %>% summarise(taux_gp2 = round(mean(as.numeric(grp)) - 1,3))
to_plot <- left_join(layer_communes, data_plot[,c("insee_com", "taux_gp2")], by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
    geom_sf(aes(fill = taux_gp2)) +
scale_fill_gradient(low = "blue", high = "yellow", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = taux_gp2), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
ggsave("../carto/carte_clusters_individus.png", width = 20, height = 20, units = "cm")
```


```{r}
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("label", "label1","label2"))

# Afficher la carte interactive
plotly_plot
htmlwidgets::saveWidget( widget = plotly_plot, file =  "../carto/carte_clusters_individus_interactive.html")
```


#### Odds et risks ratios :

```{r}
library(epitools)
# créer une fonction pour comparer chaque modalité à toutes les autres
to_bin <- function(v,m){
  vec = c()
  for(a in data_afmd %>% pull(v)){
    if(a == m) vec = c(vec,1)
    else vec = c(vec,0)
  }
  return(vec)
}
or = c()
inf = c()
sup = c()
mod = c()
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  for(m in levels(data_afmd %>% pull(v))){
    if(m == "0") break # pour ne prendre que la modalité "1" == "oui", des variables binaires + que le cluster des communes 1
    bin = to_bin(v,m)
    mod = c(mod,paste(v, m, sep = "."))
    res <-tryCatch(
      expr = {
    res = oddsratio(bin, grp)$measure[2,]
        },
    error = function(err){
            c(NA, NA, NA)
        }
    )
    or = c(or, res[1])
    inf = c(inf, res[2])
    sup = c(sup, res[3])
    if(length(levels(data_afmd %>% pull(v))) == 2) break # pour ne prendre que la première modalités des variables binaires != 0/1, (ex : majoration)
  }
}

odr = data.frame(modalité = mod, OR = or, borne_2.5 = inf, borne_97.5 = sup)

odr = odr[order(odr$OR, decreasing =  FALSE),]
odr$log_or = log(odr$OR)
odr$log_inf = log(odr$borne_2.5)
odr$log_sup = log(odr$borne_97.5)

na.omit(odr) %>% ggplot(aes(y = modalité , x = log_or, color = log_or)) +
  geom_point(size = 3) + # Points pour les valeurs de log_or
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90",  high = "#EFC000FF", midpoint = 0) +
  coord_cartesian(xlim = c(-5, 5)) +
  labs(title = "Log Odds Ratios with Confidence Intervals",
       y = "Group",
       x = "Log Odds Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
```

Plus l'odd ratio est supérieur à 1 (ou log supérieur à 0), plus il est probable que de présenter la modalité amène à être dans le groupe 2, plus l'odd ratio est inférieur à 1 (ou log inférieur à 0), plus il est probable que de présenter la modalité amène à ne pas être dans le groupe 2.

Pareil pour le risque ratio.


```{r}
rr = c()
inf = c()
sup = c()
mod = c()
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  for(m in unique(data_afmd %>% pull(v))){
    if(m == "0") break # pour ne prendre que la modalité "1" == "oui", des variables binaires
    bin = to_bin(v,m)
    mod = c(mod,paste(v, m, sep = "."))
    res <-tryCatch(
      expr = {
    res = riskratio(bin, grp)$measure[2,]
        },
    error = function(err){
            c(NA, NA, NA)
        }
    )
    rr = c(rr, res[1])
    inf = c(inf, res[2])
    sup = c(sup, res[3])
    if(length(levels(data_afmd %>% pull(v))) == 2) break # pour ne prendre que la première modalités des variables binaires != 0/1, (ex : majoration)
  }
}

risk_ratio = data.frame(modalité = mod, RR = rr, borne_2.5 = inf, borne_97.5 = sup)
risk_ratio = risk_ratio[order(risk_ratio$RR, decreasing =  FALSE),]
risk_ratio$log_rr = log(risk_ratio$RR)
risk_ratio$log_inf = log(risk_ratio$borne_2.5)
risk_ratio$log_sup = log(risk_ratio$borne_97.5)

risk_ratio %>% ggplot(aes(y = reorder(modalité, log_rr) , x = log_rr, color = log_rr)) +
  geom_point(size = 3) + 
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90",  high = "#EFC000FF", midpoint = 0) +
  coord_cartesian(xlim = c(-4, 4)) +
  labs(title = "Log risk Ratios with Confidence Intervals",
       y = "Group",
       x = "Log risk Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
```

Grands intervalles de confiance : La où il y a de petits effectifs

Rouge / en haut = groupe 2 : résultats signficatifs : log(bornes 2.5 %) > 0 <=> bornes 2.5% >1
Bleu / en bas = groupe 1 : résultats signficatifs : log(bornes 97.5 %) <  <=> bornes 97.5 % <1


#### Régression logistique :




```{r}
# sans les doublons
rl = glm(grp~., data = data_afmd[,setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))],  family = binomial(logit))
```

```{r}
# s = summary(rl)
# Coefficients du modèle
# coefficients <- coef(rl)
# 
# # Calcul des odds ratios
# odds_ratios <- exp(coefficients)
# odds_ratios

library(questionr)
odr = odds.ratio(rl)
# coeff = as.data.frame(rl$coefficients)
# s$r.squared
```

```{r, eval = FALSE}
# avec un régression logistique :
odr = odr[order(odr$OR, decreasing =  FALSE),]
odr$log_or = log(odr$OR)
odr$log_inf = log(odr$`2.5 %`)
odr$log_sup = log(odr$`97.5 %`)
odr$groupe_entree = row.names(odr)

odr[odr$groupe_entree != "(Intercept)",] %>% ggplot(aes(y = reorder(groupe_entree, log_or) , x = log_or, color = log_or)) +
  geom_point(size = 3) + # Points pour les valeurs de log_or
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "blue", mid = "grey90", high = "red", midpoint = 0) +
  coord_cartesian(xlim = c(-40, 40)) +
  labs(title = "Log Odds Ratios with Confidence Intervals",
       y = "Group",
       x = "Log Odds Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
```




```{r}
rl = lm(taux_dossiers_habitant~. -insee_com - commune - Territoire - taux_dossiers_menages - n - taux_dossiers_maisons, data = data_test)
s = summary(rl)
s$r.squared
# , "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")
```

```{r}
tdh = data_test %>% pull("taux_dossiers_habitant")
for(v in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
vd = data_test %>% pull(v) 
rl = lm(tdh~vd)
s = summary(rl)
print(v)
print(s$r.squared)
}
# , "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")
```


### Avec 3 groupes :

```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 3, nstart = 25) # séparation dim 1 et 2
grp3 <- as.factor(res.km$cluster)
summary(grp3)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp3, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2), ) 

# fviz_famd_var(res.afdm, col.var = "bisque4", "var", repel = TRUE, select.var = list("contrib" = 20))
for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  print(v)
  t = table(grp3, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2,3, "Pop totale")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  print(round(t[1:4,- dim(t)[2]],2))
   plot(round(t[1:4,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp3 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp3 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp3 == 3, ] %>% pull(v)))
}
```


```{r}
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```
gp 1 = chauffage principal (tous les jours, pôle, granulés), granulés, - riches, appareil un peu plus récents (>1996), cluster com -> 1/2
employés, (presque tous les agriculteurs), cout travaux --

gp 2 = retraités, plus de 65 ans, entre 2 au niveau des usages du chauffage, - riches, cluster com -> 2,
-> usages un peu intermédiaires

gp 3 = appoint / plaisir, bûche, plus riches, cluster com -> 2, cadre


Stockage / durée, ramonage ~ peu de diff inter - groupes

### Avec 4 groupes :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 4  , nstart = 25)
grp4 <- as.factor(res.km$cluster)
summary(grp4)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp4, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2))


for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  print(v)
  t = table(grp4, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2,3,4, "Pop totale")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  print(round(t[1:5,- dim(t)[2]],2))
  plot(round(t[1:5,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp4 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp4 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp4 == 3, ] %>% pull(v)))
  print("Groupe 4 : ")
  print(mean(data_afmd[grp4 == 4, ] %>% pull(v)))
}
```




```{r}
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```

-> apparition du groupe plaisir / agrément => séparation des moins consommateurs (cadres) en deux
-> se différencient surtout selon l'usage :  plaisir vs agrément, et l'ancien appareil : foyer ouvert vs fermé
```{r}
corresp_clusters <- data.frame(num_doss = data_afmd$N..dossier, cluster_tt = grp)
corresp_clusters <- corresp_clusters[!corresp_clusters$num_doss %in% corresp_clusters[which(duplicated(corresp_clusters$num_doss)),]$num_doss,]
write.csv(corresp_clusters, "../data/2_Travail/Clusters individus.csv")
```

### Avec 5/6 groupes :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 6, nstart = 25)
grp5 <- as.factor(res.km$cluster)
summary(grp5)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp5, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2))

# Sans prendre en comlpte le cluster "Pas de réponse"  :
for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  print(v)
  t = t(addmargins(table(grp5, data_afmd %>% pull(v))))
  t = t(t) / t[dim(t)[1],]
  print(round(t[1:6,- dim(t)[2]],2))
  plot(round(t[1:6,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp5 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp5 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp5 == 3, ] %>% pull(v)))
  print("Groupe 4 : ")
  print(mean(data_afmd[grp5 == 4, ] %>% pull(v)))
  print("Groupe 5 : ")
  print(mean(data_afmd[grp5 == 5, ] %>% pull(v)))
}
```

Apparition du grp moins de 20000 -> venant des retraités et des gros consommateurs (employés) / la plus part des agriculteurs



Plus que 5 clusters : commence à faire des tout petits groupes (<50)

En résumé on a trois groupes : retraités, forts consommateurs, moins consommateurs qu'on peut séparer en deux groupes (plaisir / foyer ouvert vs  agrément / foyer fermé)
On peut aussi faire apparaitre un 5ème groupe venant des retraités et des forts consommateurs : les plus pauvres
 : en général inter médiaires entre gros conso (employés) et retraités : se différencient moins par les usages que par les variables socio-pro
```{r}
table(grp, grp3)
table(grp3, grp4)
#table(grp4, grp5)
```


### Choix nb clusters :

```{r}
inertie.expl=c() # proportion d'inertie expliqué selon le nb de groupes
for (k in 2 :10){
  clus <- kmeans(res.afdm$ind$coord, centers=k,nstart=5)
  inertie.expl[k] <- clus$betweenss/clus$totss
}
plot(1 :10,inertie.expl,type="b",xlab="Nb. de groupes",ylab="% inertie expliquée")

```



Critère de Calinski et Harabasz : prends en compte la taille de l'échantillon, le nombre de cluster, et les sommes des carres des distances intra et inter clusters : critère à maximiser

```{r}
library(vegan)
k.event.cal <- cascadeKM(res.afdm$ind$coord, 2, 6, iter = 100, criterion = "calinski")
plot(k.event.cal)
```




### Exploration avec Factoshiny : 


```{r}
library(Factoshiny)
FAMDshiny(data_afmd[,-1]) 
```




