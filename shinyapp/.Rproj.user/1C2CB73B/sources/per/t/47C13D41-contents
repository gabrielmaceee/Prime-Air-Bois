# Ici on met tous les pretraitements qio n'ont rien a voir avec l'interface (read data, etc)
# Pour l'instant on ne l'utilisera pas.
# On pmet tout dans server.R

library(shiny)
library(readxl)
library(ggplot2)
library(dplyr)
library(tidyr)
library(janitor)
library(gridExtra)
library(sf)
library(ggspatial)
library(plotly)
library(mapview)
library(leafpop)
library(leaflet)

data <- read_excel("www/data/data.xlsx")
dico <- read_excel("www/data/dico.xlsx")
# libelles <- names(data)
# data <- data %>% 
#   clean_names()
# column_names <- names(data)
# df <- data.frame(
#   id = column_names,
#   name = libelles
# )
# write_xlsx(df , "www/data/dico.xlsx")
#write_xlsx(data , "www/data/data.xlsx")


column_names  <- dico %>% filter(to_plot == 1) 
couleur_terr <- data.frame(territoire = c("Tous", "CAPV", "GAM", "CCLG"), couleur = c("gray60", "green", "blue", "red"))
#column_name <- "Revenus"

no_plot <- c("N..dossier", "adresse_ville", "insee_com", names(data[,42:74]))
quanti <- c("Nb.pers.ménage", "Surf chauff logement", "équivalent_steres", "cout_appareil", "cout_total_TTC", "kwh", "montant_aide" )
tempo <- c("dossier_reçu", "Date_dossier_complet", "Date_refus")
quali <- setdiff(names(data), c(no_plot, quanti, tempo))
qcm <- c("Motivation du changement", "Connaissance aide", "Travaux isolation depuis 2005", "Période utilisation")


# Créer une séquence de dates avec un pas d'un mois
start_date <- as.Date("2016-01-01")
end_date <- as.Date("2023-12-01")
date_vector <- format(seq.Date(from = start_date, to = end_date, by = "month"), "%Y-%m")


get_graph <- function(df, colname, couleur){
  column_cara <- column_names %>% 
    filter(id == colname)
  if(column_cara$type == "quanti"){ # ajouter les boxplots par territoire ?
    x = as.numeric(na.omit(df %>% pull(colname)))
    p <- ggplot(df,aes(x = df %>% pull(colname))) + geom_density(color= couleur) + ggtitle(column_cara$definition) +  theme(axis.title.x=element_blank())
    grid.arrange(tableGrob(data.frame(colname = round(c(summary(x), var(x)),2),
                                      row.names = c("Minimum", "1er quartile", "Médiane", "Moyenne", "3ème quartile", "Maximum", "variance")), cols = colname),
                 p, nrow = 1)
  }
  else if(column_cara$type == "quali"){
    ggplot(df, 
           aes(x = df %>% pull(colname))) + 
      geom_bar(stat = 'count', fill = couleur) + 
      ylim(0, max(table(data %>% pull(colname)))) +
      coord_flip() + 
      ggtitle(column_cara$definition) +
      theme(axis.title.x = element_blank(),axis.title.y = element_blank())
  }
  else if(column_cara$type == "tempo"){
    par(mfrow = c(1, 3))
    df <- df[ df %>% pull(colname) > "2016-01-01" & df %>% pull(colname) < "2024-01-01",]
    temp = df %>% pull(colname)
    # par mois
    nb_mois <- format(temp,"%m")
    barplot(table(nb_mois), col = couleur, main = "Par mois")
    
    # par an : enlever 2024
    nb_an <- format(temp, "%Y")
    plot(table(sort(nb_an)), type = "l", ylab = "", col= couleur, main = "Par années")
    
    #par mois et an 
    date = data.frame(date = date_vector)
    nb_mois_an <- data.frame(table(sort(format(temp, "%Y-%m"))))
    date = left_join(date, nb_mois_an, by = join_by("date" == "Var1"))
    if(sum(is.na(date$Freq)) != 0) date[is.na(date$Freq),]$Freq <- 0
    nb_doss <- ts(date$Freq, start = c(2016, 1), end = c(2023,12), freq = 12)
    plot(decompose(nb_doss)$x, main = column_cara$definition, col= couleur)
    lines(decompose(nb_doss)$trend, col = "black")
  }
  else if(column_cara$type == "qcm"){
    column_bin <- dico %>% filter(definition == colname)
    barplot(colSums(df[, column_bin$id]), col = couleur, main = column_cara$definition, las = 1, ylim = c(0, max(colSums(data[, column_bin$id]))))
  }
}



### carto : 
layer_communes <- st_read("www/data/layer_count.shp")
names(layer_communes)[1:2] <- c("insee_com", "nom_commune")
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]
shp <- st_read(dsn = "www/data/EPCI 2024_region.shp")
shp <- shp[c(27, 175, 929),c("geometry")]
shp$sociale <- c("CCLG", "GAM", "CAPV")
names(shp)[2] <- "Territoire"
pop <- read.csv("../data/population.csv", sep = ";", skip = 2)[1:123, c(1,3)]

carto <- function(){
count <- data %>%
  group_by(insee_com) %>%
  count()
layer_communes = layer_communes %>% left_join(count)
layer_communes = layer_communes %>% left_join(pop, by = join_by("insee_com" == "communes.depcom"))

to_plot <- layer_communes %>%
          mutate(dossier_par_habitant = n/Population.en.2020)
# Créer la carte interactive avec mapview
map <- mapview(shp, col.regions = c("red", "blue", "green"), layer.name = "Territoire", legend = FALSE)
map <- map + mapview(to_plot, zcol = "dossier_par_habitant",
               col.regions = colorRampPalette(c("white", "blue")),
               legend = TRUE,
               layer.name = "Taux de dossiers par habitants",
               popup = leafpop::popupTable(to_plot, 
                                           zcol = c("nom_commune", "insee_com", "dossier_par_habitant", "n", "Population.en.2020"), row.numbers = FALSE),
               hide = FALSE)

map <- map + mapview(to_plot, zcol = "n",
                     col.regions = colorRampPalette(c("white", "blue")),
                     legend = TRUE,
                     layer.name = "Nombre de dossiers",
                     popup = leafpop::popupTable(to_plot, zcol = c("nom_commune", "insee_com", "n", "Population.en.2020"), row.numbers = FALSE), 
                     hide = TRUE)

map <- map + mapview(to_plot, zcol = "Population.en.2020",
                     col.regions = colorRampPalette(c("white", "blue")),
                     legend = TRUE,
                     layer.name = "Population",
                     popup = leafpop::popupTable(to_plot, zcol = c("nom_commune", "insee_com", "Population.en.2020"), row.numbers = FALSE), hide = TRUE)

leaflet_map <- map@map
leaflet_map
}




#### Graphiques spécifiques : 
# Sélectionner que les années d'interêt :
df <- data[data %>% pull("dossier_recu") > "2016-01-01" & data %>% pull("dossier_recu") < "2024-01-01",]
df$dossier_recu <- format(df$dossier_recu, "%Y")

demande_territoire <- function(){
plot <- df %>%
  group_by(dossier_recu, territoire) %>%
  summarise(n = n()) %>%
  ggplot(aes(x = dossier_recu, y =  n, group = territoire, color = territoire)) +
  geom_point() + geom_line()
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot)
plotly_plot
}



taux_majoration <- function(){
  counts_pv = table(df[df$majoration == "M" & df$territoire == "CAPV" ,]$dossier_recu)/ table(df[df$territoire == "CAPV" ,]$dossier_recu)
  counts_g = table(df[df$majoration == "M" & df$territoire == "CCLG" ,]$dossier_recu)/ table(df[df$territoire == "CCLG" ,]$dossier_recu)
  counts_gam = table(df[df$majoration == "M" & df$territoire == "GAM" ,]$dossier_recu)/ table(df[df$territoire == "GAM" ,]$dossier_recu)

  # Combinez les données en un data frame
  df <- data.frame(
    year = as.numeric(names(counts_gam)),
    Grenoble_Metropole = as.numeric(counts_gam),
    Gresivaudan = as.numeric(counts_g),
    Pays_Voironnais = as.numeric(counts_pv))

  # Transformez les données en format long
  df_long <- pivot_longer(df, cols = -year, names_to = "Territoire", values_to = "Taux_majorees")

  plot <- ggplot(df_long, aes(x = year, y = Taux_majorees, color = Territoire)) +
    geom_line() +
    labs(title = "Évolution du taux de primes majorées par an",
         x = "Année",
         y = "Taux de primes majorées") +
    scale_color_manual(values = c("Grenoble_Metropole" = "blue", "Gresivaudan" = "red", "Pays_Voironnais" = "green")) +
    theme_minimal() +
    theme(legend.position = "topleft")
  # Convertir l'objet ggplot en plotly
  plotly_plot <- ggplotly(plot)
  plotly_plot

}

evo_revenus <- function(territoire_name){
  if(territoire_name == "Tous"){df <- df}
  else{df <- df %>%
    filter(territoire == territoire_name)}
  plot <- df[!is.na(df$revenus),] %>%
    group_by(dossier_recu, revenus) %>%
    summarise(n = n()) %>%
    ggplot(aes(x = dossier_recu, y =  n, group = revenus, color = revenus)) +
    geom_point() + geom_line()
  # Convertir l'objet ggplot en plotly
  plotly_plot <- ggplotly(plot)
  plotly_plot
}

aide_terr <- function(){
  plot <- ggplot(data, aes(x=territoire, y=montant_aide, fill = territoire)) +
    geom_boxplot()+
    scale_fill_manual(values=c("green", "red", "blue"))
  plotly_plot <- ggplotly(plot)
  plotly_plot
}
