---
title: "ACP communes"
author: "Gabriel Macé"
date: "2024-06-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE)
```

```{r, include=FALSE}
library(readxl)
library(writexl)
library(stringr)
library(tidyr)
library(sf)
library(dplyr)
library(stats)
library(ggplot2)
library(stats)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(fastDummies)
library(plotly)
library(reshape2)
library(epitools)
library(ggtext)
library(car)
library(vegan)
```


```{r, include=FALSE}
# Accèder aux serveurs :
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```

```{r}
# Récuperer et transformer les données : 
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$insee_com %in% c("38453","38278", "38526", "38194", "38118", "38013", "38248", "38450", "38236", "38412", "38405", "38442", "38446", "38378"),]
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]
# data <- data[!is.na(data$transfert_facture),]

binaire <- read_excel("../data/2_Travail/export_questionnaire_binaire.xlsx")
binaire <- binaire[binaire$`N° dossier` %in% data$N..dossier,]
binaire <- binaire[,c(1,50:54)]
binaire <- left_join(binaire, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire <- binaire[!duplicated(binaire$`N° dossier`),c(2:7)]
# regrouper certaines modalités de la raison du changement d'appareil
binaire$`Qualité_air` <- binaire$`Qualité air de mon logement` + binaire$`Qualité de l'air extérieur`
binaire[binaire$`Qualité_air` == 2,]$`Qualité_air` <- 1
binaire$économiser <- binaire$`Économiser de l'argent` + binaire$`Économiser du bois/énergie`
binaire[binaire$économiser == 2,]$économiser <- 1
binaire <- binaire[, c(4,6:8)]
```


```{r}
data_acp <- data[,c(1,43)] %>% group_by(insee_com) %>% count()

#quanti = c("cout_total_TTC", "montant_aide","cout_appareil") # , "équivalent_steres"
quali = c("Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration"
          )
#  "Année.installation",
for(col in quali){
df_long <- data[,c(col, "insee_com")]
df_long <- dummy_cols(df_long, select_columns = col, remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, df_binary, by = "insee_com")
}

df <- data[,c("insee_com","cout_total_TTC")] %>% group_by(`insee_com`) %>% summarise(cout_total_TTC = mean(na.omit(cout_total_TTC)))
data_acp <- left_join(data_acp, df, by = "insee_com")

df <- data[,c("insee_com","montant_aide")] %>% group_by(`insee_com`) %>% summarise(montant_aide = mean(na.omit(montant_aide)))
data_acp <- left_join(data_acp, df, by = "insee_com")

binaire2 <- binaire %>% group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, binaire2, by = "insee_com")

for(i in setdiff(names(data_acp), c("insee_com", "n", "montant_aide"))){
  data_acp[,i] = data_acp[,i] / data_acp$n
}
terr = data[,c("Territoire","insee_com")]
terr = terr[!duplicated(terr$insee_com),]
data_acp <- left_join(data_acp, terr, by = "insee_com")
```

```{r}
names(data_acp) <- c("insee_com", "n",
                     "old_foyer_ouvert", "old_insert_fermé", "Type.Ancien.appareil_Pas de réponse", "old_Poêle", 
                     "old_appoint", "old_principal", "Usage.ancien.matériel_Pas de réponse", "old_agrément", 
                     "new_insert_fermé", "Nouveau.matériel_Pas de réponse", "new_Poêle", 
                     "Type.combustible.nouveau.materiel_autre", "Bûche", "Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", 
                     "new_appoint", "new_principal", "Usage.nouveau.matériel_Pas de réponse", "new_agrément", 
                     "majorée", "majoration_NM", "majoration_NA", "cout_total_TTC", "montant_aide",
                     "confort", "Qualité_air","économiser", "Territoire")
```


```{r, include=FALSE}
comm <- read.csv("../data/siddt.csv", sep = ";", skip = 2)[-c(124:130),c(1,2, 3,4,6)]
comm2 <- read.csv("../data/siddt2.csv", sep = ";", skip = 2)[-c(124:130),c(1, 3:5)]
logement = read.csv("../data/logements_2020.csv", sep =";", skip= 2)[-c(124:130),c(1,7,8)]
objectifs_communes <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[1:123,1:4]
oc <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[124:239,c(2,4)]
objectifs_communes <- left_join(objectifs_communes, oc, by = "id_comm")
objectifs_communes$id_comm = as.character(objectifs_communes$id_comm)
objectifs_communes = objectifs_communes[,c(2,4,5)]
names(objectifs_communes)= c("insee_com", "objectifs_2022", "changement_2023")
objectifs_communes$changement_2023 = abs(objectifs_communes$changement_2023)
objectifs_communes[is.na(objectifs_communes$changement_2023), "changement_2023"] <- 0
revenus_communes <- read_xlsx("../data/revenu_communes_insee.xlsx", skip = 5, col_names = TRUE)
revenus_communes <- revenus_communes[revenus_communes$CODGEO %in% data$insee_com,]
revenus_communes = revenus_communes[, c(1, 3:5)]
names(revenus_communes) = c("insee_com", "nb_ménages_fiscaux", "nb_personnes_menages_fiscaux", "mediane_niveau_vie")
types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome très peu dense", "rural autonome peu dense",  "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
surf_bois <- read_excel("../data/surface_boisee_off_2023.xlsx", sheet = "données")
surf_bois = surf_bois[surf_bois$`INSEE commune` %in% data$insee_com,c("INSEE commune", "Surface commune", "feuillus", "mixtes")]
```


```{r}
count <- data %>%
  group_by(insee_com) %>%
  count()
fo <- data[data$Type.Ancien.appareil != "Foyer ouvert",] %>%
  group_by(insee_com) %>%
  count()
buche <- data[data$Type.combustible.nouveau.materiel == "Bûche",] %>%
  group_by(insee_com) %>%
  count()
maj <- data[data$majoration == "M",] %>% group_by(insee_com) %>% count()
names(comm) <- c("communes.depcom","commune", "superficie_foret", "taux_forets", "évolution_nb_logements")
data_test = left_join(count, comm, by = join_by("insee_com" == "communes.depcom"))
names(comm2) <- c("communes.depcom", "Densité_pop", "Part_résidences_principales_loc", "part_maisons")
data_test <- data_test %>% left_join(comm2, by = join_by("insee_com" == "communes.depcom"))
names(logement) = c("insee_com","nb_maisons_rp_2020", "part_résidences_principales")
data_test <- data_test %>% left_join(logement, by = "insee_com")
data_test <- data_test %>% left_join(types_communes, by = "insee_com")
data_test <- data_test %>% left_join(objectifs_communes, by = "insee_com")
data_test <- data_test %>% left_join(revenus_communes, by = "insee_com")
data_test <- na.omit(data_test)
data_test[, "taux_dossiers_habitant"] = data_test$n / as.numeric(data_test$nb_personnes_menages_fiscaux)
data_test[, "taux_changement"] = data_test$changement_2023 / data_test$objectifs_2022
data_test[, "objectifs_2022_par_maison"] = data_test$objectifs_2022 / as.numeric(data_test$nb_maisons_rp_2020)
data_test[, "taux_feuillus"] = surf_bois$feuillus / surf_bois$`Surface commune`
data_test[, "taux_feuillus_mixte"] = (surf_bois$feuillus + surf_bois$mixtes) / surf_bois$`Surface commune`
```



# <span style="color: red;"> <u> Ensemble des demandeurs de prime : </u> </span>

## Test de normalité de Shapiro-Wilk :

Nous allons tester la normalité des distributions, afin d'identifier un éventuel effet "commune".

Si les comportements des bénéficiaires sont les mêmes dans chaque commune, alors les distributions devraient être normales.

H0 : "La distribution suit une loi normale".

Etant donné que je fais 31 tests, j'utilise la correction de Benjamin-Hochberg :

```{r, include = FALSE}
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
pval = c()
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
    qqnorm(data_acp %>% pull(col), main = col)
  plot(density(data_acp %>% pull(col)), main = col)
    pval = c(pval, shapiro.test(data_acp %>% pull(col))$p.value) # H0 : la distribution suit une loi normale
}

res = data.frame(var = setdiff(names(data_acp), c("insee_com","Territoire")), p_valeur =  p.adjust(pval, method = "BH", n = length(pval)))
```
Seules 2 des 31 variables sont normalement distribuées.
```{r, include = FALSE}
# Les variables ne suivant pas une loi normale : 
res[res$p_valeur < 0.05,]
```


```{r, include = FALSE}
# Les variables normalement distribuées :
res[res$p_valeur > 0.05,] # que 2 distributions normales
```



## ACP :

Je ne garde pas les communes ayant moins de 10 dossiers

Variables utilisées : 
"Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration", "cout_total_TTC, et "Motivation changement appareil"

J'enlève les variables représentant les modalités de type "autre", "pas de réponse, "NA", et une des modalités des variables devenues binaires (combustible, majoration)
```{r}
data_acp <- data_acp[,setdiff(names(data_acp),c("Type.Ancien.appareil_Pas de réponse", "Usage.ancien.matériel_Pas de réponse", "Nouveau.matériel_Pas de réponse", "Type.combustible.nouveau.materiel_autre","Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", "Usage.nouveau.matériel_Pas de réponse", "majoration_NA"
                                                ,"new_insert_fermé", "Granulés", "majoration_NM"
                                                # , "Qualité air de mon logement","Économiser du bois/énergie","Économiser de l'argent","Gagner en confort/chaleur", "Qualité de l'air extérieur"
))]

# variable devenues binaires :
# ,"Nouveau.matériel_Insert / foyer fermé", "Type.combustible.nouveau.materiel_Granulés", "majoration_NM"
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
for(col in setdiff(names(data_test), c("insee_com","commune","type_commune"))){
  data_test[,col] <- as.numeric(data_test %>% pull(col))
}

```

```{r, include = FALSE}
data_acp <- data_acp[data_acp$insee_com %in% data_test$insee_com,]
data_acp = data_acp[data_acp$n >= 10,]
df = left_join(data_acp, data_test[,setdiff(names(data_test),c("n","commune"))], by = "insee_com")
df$montant_aide = df$montant_aide / df$nb_ménages_fiscaux
res.pca <- PCA(df[, 2:dim(df)[2]], quanti.sup = c("n", "montant_aide", setdiff(names(data_test),"type_commune")),quali.sup = c("Territoire","type_commune"), ncp = 10)
```
### Valeurs propres :
```{r}
eig.val <- get_eigenvalue(res.pca)
head(eig.val, n = 10)
```
Les 6 premières dimensions expliquent plus de 80% de la variance, on gardera quand même les 10 premières pour les clusterings.

```{r}
#row.names(res.pca$ind$coord) <- na.omit(data_afdm)$commune
fviz_pca_ind(res.pca, habillage = "Territoire", palette = c("green","red", "blue"))
```

Il semble y avoir une légère séparation par territoire, sur les deux premières dimensions.

```{r}
fviz_pca_var(res.pca, select.var = list("contrib" = 10))
```

### Contribution et représentation des variables : 

Pourcentage de variance expliquée par les différentes dimensions :
```{r}
#La fonction fviz_eig() ou fviz_screeplot() [factoextra] peut être utilisée pour visualiser les proportions de variances expliquées par les différents axes:
  fviz_screeplot(res.pca)
```

1ère dimension = très importante

```{r}
var = get_pca_var(res.pca)
corrplot(var$contrib[,1:10], is.corr = FALSE) 
corrplot(var$cos2[,1:10], is.corr = FALSE) # qualité de représentation
fviz_contrib(res.pca, choice = "var", axes = c(1,2))
fviz_cos2(res.pca, choice = "var", axes = c(1,2))
```

Les variables de raisons de changement d'appareil, et le cout ttc des travaux ne semblent pas très importants.
Les autres semblent toutes assez bien représentées par les deux premières dimensions.
Il est difficile d'observer des clusters de variables par dimensions.

### Type de communes  :

```{r}
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5"))
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 4), "red", "red"))
# fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 3), rep("green",2), "red"))
# fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("yellow","yellow", "orange", "red", "brown", "black"))
```

Les deux premières dimensions semblent bien séparer les communes urbaines des rurales

## Clustering :
### Clustering ascendant hiérarchique : 

```{r}
row.names(res.pca$ind$coord) <- data_acp[data_acp$n >= 10,]$insee_com
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D")
plot(hc)
rect.hclust(hc,k=2)

memb <- as.factor(cutree(hc, k = 2))
fviz_pca_ind(res.pca, col.ind = memb, palette =  c("seagreen","coral3", "mediumslateblue"), legend.title = "Cluster",addEllipses = FALSE)
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D2")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 3))
fviz_pca_ind(res.pca, col.ind = memb, palette =  c("seagreen","coral3", "mediumslateblue"), legend.title = "Cluster",addEllipses = FALSE)
```

Le dendogramme semble suggérer de créer 2 clusters, voir 3.

### K-means :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)# Créez 2 groupes de variables (centers = 2)
grp <- as.factor(res.km$cluster)
# Colorer les variables par groupes
fviz_pca_ind(res.pca, col.ind = grp, palette =  c("seagreen","coral3", "mediumslateblue"), legend.title = "Cluster",addEllipses = FALSE)
fviz_pca_ind(res.pca, col.ind = grp, palette =  c("seagreen","coral3", "mediumslateblue"), legend.title = "Cluster",addEllipses = FALSE, axes = c(1,3))
fviz_pca_ind(res.pca, col.ind = grp, palette =  c("seagreen","coral3", "mediumslateblue"), legend.title = "Cluster",addEllipses = FALSE, axes = c(2,3))
```

La méthode k-means semble bien séparer les deux groupes, en particulier selon la première dimension.



```{r}
fviz_pca_biplot(res.pca, col.var = "bisque4", label = c( "var"), select.var = list("contrib" = 9), col.ind = grp, palette =  c("seagreen","coral3", "mediumslateblue"),repel = TRUE)
```

Le groupe 1 semble être marqué par des taux forts de : anciens poêles, primes majorées, anciens et nouveaux usages principaux.

Le groupe 2 semble être marqué par des taux forts de : anciens foyers ouverts, anciens usages agrément, et de nouveaux et anciens usages d'appoint


```{r}
fviz_pca_biplot(res.pca, col.var = "transparent", label = "quanti.sup", col.ind = grp, palette = c("seagreen","coral3", "mediumslateblue"), repel = TRUE)
```


### Carte des clusters : 


```{r, include = FALSE}
# Get polygons communes data
sql <- "SELECT insee_com, nom_m AS nom_commune, the_geom 
        FROM bd_admin_express.geo_commune_2022
        WHERE insee_dep = '38'
		    ORDER BY 1"
layer_communes <- st_read(con, query = sql)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]

shp <- st_read(dsn = "../data/EPCI 2024_region.shp")
shp = shp[c(27, 175, 929),]
shp$ sociale <- c("CCLG", "GAM", "CAPV")
```

```{r, include = FALSE}
col = c("seagreen","coral3", "mediumslateblue")
grp <- data.frame(grp)
grp$insee_com = rownames(grp)
to_plot <- left_join(layer_communes, grp, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = grp)) +
    scale_fill_manual(values = c("1" = col[1], "2" = col[2], "3" = col[3])) +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = grp), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
ggsave("../carto/carte_clusters_communes.png", width = 20, height = 20, units = "cm")
```

```{r}
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("label", "label1","label2"))

# Afficher la carte interactive
plotly_plot
htmlwidgets::saveWidget( widget = plotly_plot, file =  "../carto/carte_clusters_communes_interactive.html")
```

## Carte du type de commune
```{r, include = FALSE}
tp2 = types_communes[types_communes$insee_com %in% data$insee_com,]
levels(tp2$type_commune) <- c("rural", "rural", "rural","rural", "urbain", "urbain")

to_plot <- left_join(layer_communes, tp2, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  scale_fill_manual(values = c("rural" = col[1], "urbain" = col[2])) +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
ggsave("../carto/carte_types_communes_simplifiés.png", width = 20, height = 20, units = "cm")
```

```{r}
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("label", "label1","label2"))

# Afficher la carte interactive
plotly_plot
htmlwidgets::saveWidget( widget = plotly_plot, file =  "../carto/carte_types_communes_simplifiés_interactive.html")
```

```{r, include = FALSE}
to_plot <- left_join(layer_communes, types_communes, by = "insee_com")
col = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  scale_fill_manual(values = c("rural autonome peu dense" = col[1], "rural autonome très peu dense" = col[2], "rural sous faible influence d'un pôle" = col[3], "rural sous forte influence d'un pôle" = col[4], "urbain densité intermédiaire" = col[5], "urbain dense" = col[6] )) +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
ggsave("../carto/carte_types_communes.png", width = 20, height = 20, units = "cm")
```

```{r}
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("label", "label1","label2"))

# Afficher la carte interactive
plotly_plot
htmlwidgets::saveWidget( widget = plotly_plot, file =  "../carto/carte_types_communes_interactive.html")
```

## Lien entre les cluters et les types de communes
```{r}
table <- table(grp$grp, tp2[tp2$insee_com %in% data_acp$insee_com,]$type_commune)
table
```
Deux groupes : un plus urbain, l'autre plus rurale mais pas mal de confusion
      rural urbain
  1    37     22
  2    10     42

Trois groupes : un urbain, un rural, un mixte

    rural urbain
  1     4     31
  2    22     33
  3    21      0
  
  
```{r}
t = t(addmargins(table))
t = t / t[,3]
t = t[1:2,1:2]
round(t,2)
```



```{r}
table2 <- table(grp$grp, types_communes[types_communes$insee_com %in% data_acp$insee_com,]$type_commune)
table2
```
Groupe 1 = Rurales

Groupe 2 = rural sous faible influence d'un pôle, rural sous forte influence d'un pôle, urbain (principalement intermédiaire)
Communes intermédiaires ?

Groupe 3 = urbain + rurale sous forte influence d'un pôle

```{r}
t2 = t(addmargins(table2))
t2 = t2 / t2[,3]
t2 = t2[1:6,1:2]
round(t2,2)
```

```{r, include = FALSE }
# Heat map des correspondances entre les clusters et les types de communes, pas forcément pertinent
ggplot(data = melt(t), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()

ggplot(data = melt(t2), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```

Calcul des odds ratio pour connaitre l'effet des modalités des types de communes sur les groupes : 
```{r}
# créer une fonction pour comparer chaque modalité à toutes les autres
grp <- left_join(grp, types_communes, by = "insee_com")

or = c()
inf = c()
sup = c()
mod = c()

for(m in levels(grp %>% pull("type_commune"))){
  vec = c()
  for(a in grp %>% pull("type_commune")){
    if(a == m) vec = c(vec,1)
    else vec = c(vec,0)
  }
    mod = c(mod, m)
    res <-tryCatch(
      expr = {
    res = oddsratio(vec, grp$grp)$measure[2,]
        },
    error = function(err){
            c(NA, NA, NA)
        }
    )
    or = c(or, res[1])
    inf = c(inf, res[2])
    sup = c(sup, res[3])
    if(length(levels(grp %>% pull("type_commune"))) == 2) break # pour ne prendre que la première modalité des variables binaires != 0/1, (ex : majoration)
}

odr = data.frame(modalité = mod, OR = or, borne_2.5 = inf, borne_97.5 = sup)

odr = odr[order(odr$OR, decreasing =  FALSE),]
odr$log_or = log(odr$OR)
odr$log_inf = log(odr$borne_2.5)
odr$log_sup = log(odr$borne_97.5)
odr$modalité = factor(odr$modalité, levels = odr$modalité)
na.omit(odr) %>% ggplot(aes(y = modalité , x = log_or, color = log_or)) +
  geom_point(size = 3) + # Points pour les valeurs de log_or
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "seagreen", mid = "grey90",  high = "coral3", midpoint = 0) +
  #coord_cartesian(xlim = c(-5, 5)) +
  labs(title = "Log Odds Ratios with Confidence Intervals",
       y = "Group",
       x = "Log Odds Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
#ggsave("../data/3_Resultat/graphes/Clusters/Individus/odds_ratios.png", device = "png", bg = "white", width = 20, height = 20, units = "cm")
```

 Un log(odds ratio) : 
 
 < 0 signifie que l'événement "être dans le groupe 2" est moins fréquent dans ce groupe par rapport à l'ensemble des autres, signifatif si la borne sup l'est aussi.
 
= 0 signifie que l'événement est aussi fréquent dans les deux groupes.

 '>' 0 signifie que l'événement "être dans le groupe 2" est plus fréquent dans ce groupe par rapport à l'ensemble des autres, signifatif si la borne inf l'est aussi.
 
 On ne peut pas calculer l'OR pour les communes peu dense et très peu dense car elles sont trop peu nombreuses.



```{r}
## Comparaison Urbain / rural
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "rural",]$Type.combustible.nouveau.materiel_Bûche)
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "urbain",]$Type.combustible.nouveau.materiel_Bûche)

# data <- left_join(data, types_communes, by = "insee_com")
# data <- left_join(data, tp2, by = "insee_com")
# boxplot(data_acp$Type.combustible.nouveau.materiel_Bûche ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# boxplot(data_acp$Type.combustible.nouveau.materiel_Granulés ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.y)/ table(data$type_commune.y)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.y)/ table(data$type_commune.y)
```


```{r}
# check <- data[, c("adresse_ville", "insee_com", "Type.combustible.nouveau.materiel", "type_commune.x")]
# check_gre <- check[check$adresse_ville %in% c("GRENOBLE"),c(3)]
# write_xlsx(check, "../data/3_Resultat/check_communes.xlsx")
# write_xlsx(check_gre, "../data/3_Resultat/check_Grenoble.xlsx")
```




## Récupération des clusters par individus : 
```{r}
set.seed(3)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)
grp <- as.factor(res.km$cluster)
```


```{r}
# ! ne pas mettre plusieurs fois
entree <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
# sortie <- data.frame(cluster_com = grp, insee_com = rownames(as.data.frame(grp)))
# sortie <- left_join(entree, sortie, by = "insee_com")
# write_xlsx(sortie, "../data/3_Resultat/data_questionnaire_complet.xlsx")
plot(table(format(entree[entree$cluster_com == "1" ,]$dossier_reçu, "%Y"))[-c(1)] / table(format(entree$dossier_reçu, "%Y"))[-c(1)],
     type = "l", col ="pink", main = "évolution des taux de demandeurs par cluster", ylim = c(0,1), ylab = "")
lines(table(format(entree[entree$cluster_com == "2" ,]$dossier_reçu, "%Y")) / table(format(entree$dossier_reçu, "%Y"))[-c(1)], 
      type = "l", col ="purple")
legend("bottomleft", legend=c("1", "2"),  col=c("pink","purple"), lty=1, cex=0.8, bg="transparent", title = "Clusters")

# Si les clusters n'ont pas encore été ajouté au jeu de donnée : 
# plot(table(format(sortie[sortie$cluster_com == "1" ,]$dossier_reçu, "%Y"))[-c(1)] / table(format(sortie$dossier_reçu, "%Y"))[-c(1)],
#      type = "l", col ="pink", main = "évolution des taux de changement de type de combustible")
# lines(table(format(sortie[sortie$cluster_com == "2" ,]$dossier_reçu, "%Y")) / table(format(sortie$dossier_reçu, "%Y"))[-c(1)], 
#       type = "l", col ="purple")
# legend("bottomleft", legend=c("1", "2"),  col=c("pink","purple"), lty=1, cex=0.8, bg="transparent")
```

Stable au cours du temps même si les taux sont un peu extrêmes en 2015 et en 2024 : pas l'année complète


## Différences inter-groupes : 

```{r}
# interprétation des variables / groupes
stat.comp <- function(x,y){
  K <- length(unique(y))# Nombre de groupes
  n <- length(x)# Nombre d’observations
  m <- mean(x)# Moyenne globale
  TSS <- sum((x-m)^2) # Variabilité totale
  nk <- table(y) # Effectifs conditionnels
  mk <- tapply(x,y,mean) # Moyennes conditionnelles
  BSS <- sum(nk * (mk - m)^2) # Variabilité expliquée
  result <- c(mk,100.0*BSS/TSS) # Moyennes + prop. variance expliquée
  names(result) <- c(paste("G",1 :K),"% epl.")# Nommer les élements du vecteur
  return(result) # Renvoyer le vecteur résultat
}

```


```{r}
data_test = data_test[data_test$n >=10, ]
data_test_cr = data_test
data_test_cr = data.frame(data_test_cr)
```

```{r}
for(i in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
  data_test[,i] <- as.numeric(data_test %>% pull(i))
  data_test_cr[,i] <- scale(as.numeric(data_test %>% pull(i)))
}
```



### Variables de l'ACP :
Le tableau présente les différences de moyennes entre les deux groupes, pour les variables centrées réduites (cr) et brutes, ainsi que la proportion de variance de la variable expliquée par la séparation en groupes (X..epl).

```{r}
var = setdiff(names(data_acp), c("insee_com","Territoire","n"))
df = data_acp[data_acp$n >= 10, var]
df = scale(df)
df = data.frame(df)
t = data.frame(round(sapply(df,stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_acp[data_acp$n >= 10, var],stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
#ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"
```{r}
res = c()
anova = c()
for(v in names(df)){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(df[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(df[,v]~grp))[[1]][1,5] )
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
```

Représentation des différences inter-groupe, en fonction des résultats des tests :
```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```

```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr, 1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon","pval anova", "index")
dataf
```
Groupe 1 : (+ rural)
```{r}
dataf[dataf$Diff_grp > 0,]$variables
```
Majorés, chauffage principal, raisons changement : plus de modalités / croisement, taux de poêle nouveau ++, ancien : plus d'insert et de poêle que le groupe 2


Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0,]$variables
```

Non majorés, ont un usage moins important de leur appareil (moins dépendants), taux de buche + important

Autres représentation graphique, les variables où le texte est en gris sont celles où il y a égalité des distributions.
Les points bleus sont ceux où la moyenne du groupe 2 est plus forte que celle du groupe 1, et inversement pour les rouges :
```{r}
# Fonction pour générer les couleurs basées sur la pvalue du test de Wilcoxon : 
get_label_color <- function(pval) {
  sapply(pval , function(x) {
    if (x < 0.05) {
      return("black")  # Pour les variables où il n'y a pas égalité des distributions
    } else {
      return("grey")  # Gris pour les autres
    }
  })
}
label_colors <- get_label_color(dataf$`pval wilcoxon`)
dataf$label_colors = label_colors

# Création du plot
ggplot(dataf, aes(y = reorder(variables, abs(Diff_grp)), x = abs(Diff_grp))) +
  geom_point(aes(color = Diff_grp), size = 3) +
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90", high = "red", midpoint = 0) +
  coord_cartesian(xlim = c(0, 1.75)) +  # Étendre les limites de l'axe X
  labs(title = "Différence de moyennes",
       y = "Modalités",
       x = "Différence de moyennes") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +  # Masquer les labels originaux de l'axe Y
  geom_text(aes(y = variables, label = variables), color = label_colors, 
            nudge_x = 0.05,  # Déplacer les étiquettes vers la droite
            hjust = 0, 
            show.legend = FALSE, size = 3.5)  # Étiquettes avec couleurs définies 
ggsave("../data/3_Resultat/graphes/Clusters/Communes/diff_var_acp.png", device = "png", bg = "white", width = 20, height = 20, units = "cm")
```

```{r}
write_xlsx(dataf, "../data/3_Resultat/res_acp_communes.xlsx")
write_xlsx(dataf, "../shinyapp/www/data/res_acp_communes.xlsx")
```



### Variables supplémentaires : 

```{r}
# rl ?
var = setdiff(names(data_test), c("insee_com", "type_commune", "commune", "Territoire", "changement_2023", "nb_maisons_rp_2020")) # , "n", "objectifs_2022"
t = data.frame(round(sapply(data_test_cr[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_test[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
#ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"

```{r}
res = c()
anova = c()
#kw = c()
for(v in var){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(data_test_cr[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(data_test_cr[,v]~grp))[[1]][1,5] )
  #kw <- c(kw, kruskal.test(data_test_cr[,v]~grp)$p.value)
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
#p_value_corr_kw = p.adjust(kw, method = "BH", n = length(kw))
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr,  xlim = c(-1.5, 1.5), ylim = c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")# , col = "transparent"
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```

```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```

```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr,1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon", "pval anova", "index")
dataf
```

Groupe 1 : (+ rural)
```{r}
dataf[dataf$Diff_grp > 0,]$variables
```
Plus de primes, plus de fôrets de tout type, plus grande part de maison dans les résidences principales


Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0,]$variables
```
Plus de pop, meilleur médiane de niveau de vie, taux plus important de superficie de feuillus

```{r}
label_colors <- get_label_color(dataf$`pval wilcoxon`)
dataf$label_colors = label_colors

# Création du plot
ggplot(dataf, aes(y = reorder(variables, abs(Diff_grp)), x = abs(Diff_grp))) +
  geom_point(aes(color = Diff_grp), size = 3) +
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90", high = "red", midpoint = 0) +
  coord_cartesian(xlim = c(0, 1)) +  # Étendre les limites de l'axe X
  labs(title = "Différence de moyennes",
       y = "Modalités",
       x = "Différence de moyennes") +
  geom_vline(xintercept = 0, linetype = "dotted") +
  theme_minimal() +
  theme(axis.text.y = element_blank()) +  # Masquer les labels originaux de l'axe Y
  geom_text(aes(y = variables, label = variables), color = label_colors, 
            nudge_x = 0.05,  # Déplacer les étiquettes vers la droite
            hjust = 0, 
            show.legend = FALSE, size = 3.5)  # Étiquettes avec couleurs définies 
ggsave("../data/3_Resultat/graphes/Clusters/Communes/diff_var_spp.png", device = "png", bg = "white", width = 20, height = 20, units = "cm")
```
```{r}
write_xlsx(dataf, "../data/3_Resultat/supp_acp_communes.xlsx")
write_xlsx(dataf, "../shinyapp/www/data/supp_acp_communes.xlsx")
```




```{r, include = FALSE}
ordre = ordre[,c(1,3)]
ordre$inégalité_distributions = dataf$`pval wilcoxon` < 0.05
ordre$définition = rep("à déf", 17)
ordre <- ordre[,c(4,3,2,1)]
ordre
```

### Liens entre les variables de l'acp

```{r, include=FALSE}
# lm : H0 : X n'a pas d'effet sur Y
p_value_correlation = c()
co = c()
p_value_lm = c()
var1 = c()
var2 = c()
r2 = c()
quanti2 = c()
for(q in setdiff(names(data_acp), c("insee_com","Territoire","n"))){
  quanti2 = c(quanti2, q)
   for(q2 in setdiff(setdiff(names(data_acp), c("insee_com","Territoire","n")), quanti2)){
      ct = cor.test(as.numeric(data_acp %>% pull(q)), data_acp %>% pull(q2))
      p_value_correlation = c(p_value_correlation, ct$p.value)
      p_value_lm = c(p_value_lm,summary(lm(data_acp %>% pull(q2)~data_acp %>% pull(q)))$coefficients["data_acp %>% pull(q)", "Pr(>|t|)"]) # q explique as.numeric(grp)
      r2 =  c(r2,summary(lm(data_acp %>% pull(q2)~data_acp %>% pull(q)))$r.squared)
      co = c(co, ct$estimate)
      var1 = c(var1, q)
      var2 = c(var2, q2)
   }
}
res_corr = data.frame(q1 = var1, q2 = var2, correlation = round(co,3), p_value_corr = p.adjust(p_value_correlation, method = "BH", n = length(p_value_correlation)), r2 = round(r2,3), p_value_lm_ajustée = p.adjust(p_value_lm, method = "BH", n = length(p_value_lm)))

res_corr
```

```{r, include = FALSE}
res_corr[res_corr$q1 == "new_Poêle" | res_corr$q2 == "new_Poêle",]
```

```{r, include = FALSE}
 summary(lm(new_Poêle ~ new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              #old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
            #* Bûche * 
              , data = data_acp))
```

Le taux de nouveaux appareils de type poêle est lié et anti corrélé aux taux de : bûches, nouveaux et anciens appoints, nouveaux et anciens aggréments, (montant de l'aide)

Lié et corrélé aux taux de : majoration, nouveaux et anciens principaux
Buche : appoint +, principal -

Majorée : anti corrélé au montant de l'aide : effet Pays Voironnais ? Beaucoup de maj, prime + faible
-> lié au cout total ttc

```{r, include = FALSE}
res_corr[res_corr$q1 == "Bûche" | res_corr$q2 == "Bûche",]
```

```{r, include = FALSE}
 summary(lm(Bûche  ~ old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
           # * new_Poêle* new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              , data = data_acp))
```
Taux de bûches lié et anti corrélé à : ancien et nouveau poêle, ancien principal, majoration

Lié et corrélé à : ancien foyer ouvert, ancien et nouveau appoint, ancien aggrément

#### Choix du nombre de clusters : 

```{r}
inertie.expl=c() # proportion d'inertie expliqué selon le nb de groupes
for (k in 2 :10){
  clus <- kmeans(res.pca$ind$coord, centers=k,nstart=5)
  inertie.expl[k] <- clus$betweenss/clus$totss
}
plot(1 :10,inertie.expl,type="b",xlab="Nb. de groupes",ylab="% inertie expliquée")
```

-> Coude au niveau de 3 clusters


Critère de Calinski et Harabasz : prends en compte la taille de l'échantillon, le nombre de cluster, et les sommes des carres des distances intra et inter clusters : critère à maximiser

```{r}
k.event.cal <- cascadeKM(res.pca$ind$coord, 2, 6, iter = 100, criterion = "calinski")
plot(k.event.cal)
```

Optimal = 2 groupes.

#### Régression logistique :

```{r}
data_acp$grp = as.factor(grp)
```

```{r}
modele = (glm(grp  ~ old_foyer_ouvert * old_Poêle * old_appoint * old_principal * old_agrément 
           # * new_Poêle* new_appoint * new_principal * new_agrément * majorée * cout_total_TTC * 	montant_aide
              , family = binomial(logit), data = data_acp))
#summary(modele)
# pseudo_R2 <- 1 - modele$deviance/modele$null.deviance
# pseudo_R2
# Dans le sommaire du résultat de glm, la déviance du modèle ajusté est indiquée comme Residual Deviance.
# Le sommaire inclut aussi une autre valeur, Null Deviance, qui correspond à la déviance du modèle nul ne
# comptant aucun prédicteur. Ces deux valeurs jouent un rôle semblable à la sommes des écarts carrés résiduels
# et la somme des écarts carrés totaux dans le modèle linéaire. On peut donc définir le pseudo R2 (ou R2 de
# McFadden) comme la fraction de la déviance du modèle nul expliquée par le modèle incluant les prédicteurs

r2_tjur <- mean(modele$fitted.values[modele$y == 1]) - mean(modele$fitted.values[modele$y == 0])
r2_tjur
# le R2 de Tjur mesure la différence entre la réponse moyenne prédite pour les cas où la réponse
# observée est 1 et la réponse moyenne prédite pour les cas où la réponse observée est 0. Il indique donc à quel
# point le modèle peut “séparer” les deux groupes y = 1 et y = 0. À l’extrême, un coefficient de 0 indique que
# le modèle prédit en moyenne la même réponse pour les deux groupes, tandis qu’un coefficient de 1 indique
# que le modèle prédit avec certitude la bonne réponse pour toutes les observations
```
On prédit très bien les groupes à partir des anciens usages


# Conclusion ensemble des demandeurs :

Suite à l'acp, nous avons chercher à créer des groupes de communes, le choix de séparer en deux groupes semble le plus optimal, car il est plus simple à interpréter. De plus, la séparation entre les deux groupes se fait principalement sur la première dimension de l'ACP, or c'est sur cette dimension que la plupart des variables sont le mieux représentées.

Le premier groupe contient principalement des communes rurales et une vingtaine de communes urbaines de densité intermédiaire.
Le deuxième groupe contient principalement des communes urbaines, et quelques communes rurales sous influence d'un pôle.

Les communes du premier groupe ont un taux plus fort de chauffage principal dans les anciens et nouveaux matériels (23 et 22%), ont 13 % de plus de pôele dans les noveaux matériels, ont en moyenne un taux de prime majorées plus fort (12%), et remplissent plus de réponses dans les raisons de changement d'appareil,  par rapport au deuxième groupe.

Le deuxième groupe a un usage moins important des appareils (appoint, plaisir), avant comme après prime, et a un taux plus fort d'utilisation de la bûche dans les nouveaux appareils (15%), et des taux plus forts de chauffage d'appoint et d'aggréments, ainsi que de foyers ouverts, par rapport au premier groupe.

Il est possible que les usages des appareils influencent le type d'appareil et de combustible (Chauffage principal -> poêle à granulés). Or les usages peuvent être liés à la siutation économique de l'usager (ex : majoration de la prime).

Pour les variables supplémentaires, dans le premier groupe, il semble y avoir plus de demandes de primes par habitant, ainsi qu'une plus grande part de maison dans les résidences principales. Dans le deuxième groupe, il semble y avoir plus de population, une plus forte médiane de niveau de vie. Ce qui conforte la séparation rural / urbain des deux groupes.
Les différences entre les taux de forêts sont très faibles (entre à et 2 %), et sont plus fort tantôt pour le groupe 1, tantôt pour le 2, dépendant de la variable.

Il semble que les différences de comportement entre les deux groupes soient plutôt dues aux caractéristiques socio-économique des communes.





