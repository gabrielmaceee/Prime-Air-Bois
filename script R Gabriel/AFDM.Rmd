---
title: "AFDM"
author: "Gabriel Macé"
date: "2024-05-24"
output: html_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE)
```

```{r, include=FALSE}
library(FactoMineR)
library(factoextra)
library(readxl)
library(writexl)
library(tidyr)
library(dplyr)
library(stats)
library(missMDA)
library(corrplot)
library(ggplot2)
library(plotly)
library(reshape2)
library(stringr)
library(sf)
library(clv)
library(fastDummies)
library(epitools)
library(vegan)
```

```{r, include=FALSE}
# Pour accèder aux serveurs :
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```


```{r}
# Chargement des données :
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
data <- data[!is.na(data$dossier_reçu),]

types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome très peu dense", "rural autonome peu dense",  "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
#data <- left_join(data, binaire, by = join_by("N..dossier" == "N° dossier"))
data <- left_join(data, types_communes, by = "insee_com")

data$Revenus <- factor(data$Revenus, levels = rev(c("Pas de réponse", "Moins de 20 000 €", "20 000 à 30 000 €", "30 000 à 40 000 €", "40 000 à 50 000 €", "50 000 à 60 000 €", "60 000 à 70 000 €", "70 000 à 80 000 €", "80 000 à 90 000 €", "Plus de 100 000 €")))

data$Usage.ancien.matériel <- factor(data$Usage.ancien.matériel, levels = c("Chauffage principal", "Chauffage d'appoint", "Plaisir / agrément", "Pas de réponse"))
data$Usage.nouveau.matériel <- factor(data$Usage.nouveau.matériel, levels = c("Chauffage principal", "Chauffage d'appoint", "Plaisir / agrément", "Pas de réponse"))

data$Freq.utilisation.période.chauffe <- factor(data$Freq.utilisation.période.chauffe, levels = c("Tous les jours", "3 à 4 jours / semaine", "1 à 2 jours / semaine", "1 à 3 jours / mois", "moins souvent", "Jamais", "Pas de réponse"))

data$Durée.séchage.bois <- factor(data$Durée.séchage.bois, levels =c("<1an", "1-2 ans", "> 2 ans", "Ne sait pas", "Pas de réponse"))

data <- data %>% filter(!data$Nouveau.matériel == "Pas de réponse")

data[data$Type.Ancien.appareil == "Poêle" & data$Type.combustible %in% c("Pas de réponse", 'Autre (détails dans colonne "Type combustible autre")'),"Type.combustible"] <- "à enlever"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel %in% c("Pas de réponse", "autre", "Bûche, autre"),"Type.combustible"] <- "à enlever"
data <- data %>% filter(!data$Type.combustible == "à enlever" )
data <- data %>% filter(!data$Type.combustible.nouveau.materiel == "à enlever" )

data[data$Type.Ancien.appareil  == "Poêle" & data$Type.combustible %in% c("Bûche", "Bois de récup"),]$Type.Ancien.appareil <- "Poêle buche"
data[data$Type.Ancien.appareil  == "Poêle" & data$Type.combustible == "Granulés",]$Type.Ancien.appareil <- "Poêle granulés"

data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Bûche",]$Nouveau.matériel <- "Poêle bûche"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Bûche, Granulés",]$Nouveau.matériel <- "Poêle mixte"
data[data$Nouveau.matériel == "Poêle" & data$Type.combustible.nouveau.materiel == "Granulés",]$Nouveau.matériel <- "Poêle granulés"
```


```{r}
# Transformation des variables type qcm en binaire :
 df_long <- data[, c("N..dossier", "Stockage.bois" )] %>%
    separate_rows("Stockage.bois", sep = c(", "))
  df_long <- dummy_cols(df_long, select_columns = "Stockage.bois", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
  df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
  names = c("Stockage.bois_A l'intérieur", "Stockage.bois_Pas de réponse", "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris")
  names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier", "Stockage.bois_A l'intérieur", "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris")]
data <- data %>% left_join(df_binary, by = "N..dossier")


df_long <- data[, c("N..dossier", "Approvisionnement" )] %>%
    separate_rows("Approvisionnement", sep = c(", "))
df_long <- dummy_cols(df_long, select_columns = "Approvisionnement", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
names = c("autre (colonne Questionnaire.Appro autre)", "Pas de réponse", "Approvisionnement_personnel / gratuit", "Approvisionnement_Point de vente non spécialisé", "Approvisionnement_Producteur indépendant")
names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier","Approvisionnement_personnel / gratuit", "Approvisionnement_Point de vente non spécialisé","Approvisionnement_Producteur indépendant")]
data <- data %>% left_join(df_binary, by = "N..dossier")


df_long <- data[, c("N..dossier", "Ramonage.installation" )] %>%
    separate_rows("Ramonage.installation", sep = c(", "))
df_long <- dummy_cols(df_long, select_columns = "Ramonage.installation", remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`N..dossier`) %>%
    summarize(across(everything(), max))
names = c(" Pas de réponse", "ramonage_un professionnel", "ramonage_vous même")
names(df_binary) <- c("N..dossier",names)
df_binary = df_binary[, c("N..dossier","ramonage_un professionnel", "ramonage_vous même")]
data <- data %>% left_join(df_binary, by = "N..dossier")
```



```{r}
# Transformation des situations professionnelles :
for(cate in c("Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e")){
  data[,cate] <- rep(0, dim(data)[1])
  data[data$Sit.pro.conjoint == cate | data$Sit.pro.demandeur == cate, cate] <- 1
}
```



```{r}
# Choix des variables de l'AFDM :
# a_enlever <-c("Classe.énergétique.logement", "Type.combustible.autre", "Qtté.bois.consommée", "Qtté.bois.unité", "Appro.autre", "Origine.bois", "Fréquence.ramonage.autre", "Type.combustible.nouveau.matériel.autre", "Fréquence.utilisation.période.de.chauffe.nouveau.matériel", "Motivation.autre", "Connaissance.aide.site.internet", "Connaissance.aide.autre", "insee_com", "kwh", "transfert_facture","dossier_reçu")
# a_enlever = c(a_enlever, "équivalent_steres", "Nature.logement", "Occupation.logement", "Stockage.bois", "Type.combustible", "adresse_ville", "Motivation.changement.appareil", "Connaissance.aide", "Travaux.iso.depuis.2005", "Période.utilisation", "Sit.pro.demandeur", "Sit.pro.conjoint", "Surf.chauff.logement", "Fréquence.ramonage", "Ramonage.installation","Type.de.bois", "cout_appareil")
# #"Année.installation",  "Revenus",  "montant_aide")
# # faire un afc pour motivation changement appareil ? 
# data_afmd <- data[,setdiff(names(data), a_enlever)]


utilisation = c("Type.Ancien.appareil", "Usage.ancien.matériel", "Nouveau.matériel",  "Usage.nouveau.matériel","cout_total_TTC", "type_commune", "Territoire", "montant_aide", 
                # "économiser", "Gagner en confort/chaleur", "Qualité_air", 
                # variable ajoutées après : 
                 "Revenus", "Nb.pers.ménage", "Année.installation", "Durée.séchage.bois", "cluster_com",
               "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e"
                #"Sit.pro.demandeur"#, "Sit.pro.conjoint", "Type.combustible.nouveau.materiel",
              #,"refusé"
              # , "dossier_reçu"
              ,"Approvisionnement_personnel / gratuit", "Approvisionnement_Point de vente non spécialisé","Approvisionnement_Producteur indépendant" # "Approvisionnement",
              , "Age", "majoration", "Freq.utilisation.période.chauffe"
              , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris", # "Stockage.bois", 
              "ramonage_un professionnel", "ramonage_vous même" #, "Ramonage.installation"
                )

usage <- c("Type.Ancien.appareil", "Usage.ancien.matériel", "Nouveau.matériel",  "Usage.nouveau.matériel","cout_total_TTC", "Année.installation", "Durée.séchage.bois", "Approvisionnement_personnel / gratuit", "Approvisionnement_Point de vente non spécialisé","Approvisionnement_Producteur indépendant", "Freq.utilisation.période.chauffe"
              , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris",  "ramonage_un professionnel", "ramonage_vous même")
  
socio_pro <-c("type_commune", "Territoire", "montant_aide", "Revenus", "Nb.pers.ménage",  "cluster_com", "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e", "Age", "majoration")

data_afmd <- na.omit(data[,c("N..dossier",utilisation)])# tranche de revenu, catégorie sp 2,
# supprimer les pas de réponse dans nouvel app et type de combustible poêle
# poele -> buche, granules, mixte ancien nouveau
# enlever majoration, freq util car font doublons avec revenus et le type d'appareil / usage 
# trouver une representation ACP : var / ind


# setdiff(c(usage, socio_pro), utilisation)
```

```{r}
# Essaie remplacement des NA, mais trop long : 
# data_sans_na <- imputeFAMD(data_afmd, ncp = 10)
```


```{r}
# Calcul du nombre d'individus comportant au moins une fois la modalité "Pas de réponse" :
# c = 0
# for(i in 1:dim(data)[1]){
#   for(v in setdiff(utilisation, c("cluster_com", "cout_total_TTC","montant_aide", "Nb.pers.ménage",
#                     "Employé.e", "Cadre", "Autre,sans activité", "Retraité.e", "Ouvrier.ère", "Artisan.e, commerçant.s, chef.fe d'entreprise", "Profession intermédiaire", "Agriculteur.rice exploitant.e",
#                     "Approvisionnement_personnel / gratuit", "Approvisionnement_Point de vente non spécialisé","Approvisionnement_Producteur indépendant"
#                     , "Stockage.bois_A l'intérieur",  "Stockage.bois_Sans Abris", "Stockage.bois_Sous Abris",
#                     "ramonage_un professionnel", "ramonage_vous même", "majoration", "type_commune"
#                     )
#                    
#                    )){
#     if(data[i,v] == "Pas de réponse"){
#       c = c + 1
#       break
#     }
#   }
# }
# print(c)
# 1972
```


```{r}
# Transformation des variables quantitatives en numériques :
for(v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  data_afmd[,v] <- as.numeric(data_afmd %>% pull (v))
}
```


```{r}
# Transformation des variables qualitatives en factorielles : 
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  data_afmd[,v] <- as.factor(data_afmd %>% pull (v))
}
```


## AFDM : 
```{r}
res.afdm<- FAMD(data_afmd[,-1], sup.var = c("Territoire", "montant_aide", "cluster_com", "type_commune", "Age", "majoration", "Freq.utilisation.période.chauffe"), graph = FALSE, ncp = 54)  # ncp = 54 (dimensions), pour garder plus de 80 % de la variance

```

Valeurs propres : taux de variance expliquée
```{r}
eig.val <- get_eigenvalue(res.afdm)
head(eig.val,100)
```

2 clusters obtenus par k-means (pour vérifier que l'on n'a pas de clusters aberrant (ex : "Pas de réponse"))
```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 2, nstart = 25) # dim 1 qui sépare
grp <- as.factor(res.km$cluster)
summary(grp)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster", geom = c("point"))

#data_afmd <- data_afmd[grp == "1",c("N..dossier",utilisation)]
#res.afdm<- FAMD(data_afmd, sup.var = c("Territoire", "montant_aide", "cluster_com", "type_commune", "Age", "majoration", "Freq.utilisation.période.chauffe"), graph = FALSE, ncp = 54)
```

Avant : A chaque fois un groupe de ~380 individus se démarque -> "Pas de réponse"

-> depend pas du temps 

```{r}
# df <- data_afmd[data_afmd$dossier_reçu > "2016-01-01" & data_afmd$dossier_reçu < "2024-01-01" & !is.na(data_afmd$dossier_reçu) & grp=="1",]
# df$dossier_reçu <- format(df$dossier_reçu, "%Y")
# 
# df %>%
#   group_by(dossier_reçu, Territoire) %>%
#   summarise(n = n()) %>%
#   ggplot(aes(x = dossier_reçu, y =  n, group = Territoire, color = Territoire)) +
#   geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
#                                  x = "Année",
#                                  y = "Nombre de primes majorées") +
#   scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
# 
# df <- data_afmd[data_afmd$dossier_reçu > "2016-01-01" & data_afmd$dossier_reçu < "2024-01-01" & !is.na(data_afmd$dossier_reçu) & grp=="2",]
# df$dossier_reçu <- format(df$dossier_reçu, "%Y")
# 
# df %>%
#   group_by(dossier_reçu, Territoire) %>%
#   summarise(n = n()) %>%
#   ggplot(aes(x = dossier_reçu, y =  n, group = Territoire, color = Territoire)) +
#   geom_point() + geom_line() + labs(title = "Évolution de la demande de primes par an",
#                                  x = "Année",
#                                  y = "Nombre de primes majorées") +
#   scale_color_manual(values = c("GAM" = "blue", "CCLG" = "red", "CAPV" = "green"))
```

Pourcentage de variance expliquée par les différentes dimensions :
```{r}
#La fonction fviz_eig() ou fviz_screeplot() [factoextra] peut être utilisée pour visualiser les proportions de variances expliquées par les différents axes:
fviz_screeplot(res.afdm)
```


```{r, include = FALSE}
var = get_famd_var(res.afdm)
corrplot(var$contrib[,1:20], is.corr = FALSE) 
corrplot(var$cos2[,1:20], is.corr = FALSE) # qualité de représentation
fviz_contrib(res.afdm, choice = "var", axes = c(1,2))
fviz_cos2(res.afdm, choice = "var", axes = c(1,2))
```


```{r, fig.cap="plus forcément très pertinent à analyser avec la décomposition de certaines variables en binaires"}
fviz_contrib(res.afdm, choice = "var", axes = c(1:48), top = 30)
fviz_cos2(res.afdm, choice = "var", axes = c(1:48), top = 30)
```

-> plus forcément très pertinent à analyser avec la décomposition de certaines variables en binaires

```{r}
# plot.FAMD(res.afdm,title="Graphe des individus et des modalités")
# plot.FAMD(res.afdm,axes=c(1,2),choix='var',title="Graphe des variables")
# fviz_famd_var(res.afdm, col.var = "bisque4", repel = TRUE )
# plot.FAMD(res.afdm, choix='quanti',title="Cercle des corrélations")
```

Les individus se différencient ils selon le territoire (sur les deux premières dimensions) ?
```{r}
fviz_famd_ind(res.afdm, habillage = "Territoire", palette = c("green","red", "blue"), geom = c("point"))
# capv = en dernier donc se mettent au dessus des autres
```

Pas vraiment

## Clustering :
### Clustering ascendant hiérarchique : 

```{r}
hc <- hclust(dist(res.afdm$ind$coord), method = "ward.D")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 2))
fviz_famd_ind(res.afdm, habillage =  memb, label = c( "var"), palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)

hc <- hclust(dist(res.afdm$ind$coord), method = "ward.D2")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 2))
fviz_famd_ind(res.afdm, habillage = memb, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, label = c( "var"),)

```

Dendogramme : Plutôt deux clusters, mais le CAH sépare mal les deux clusters sur les deux premières dimensions


### Avec 2 groupes :

```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 2, nstart = 25) # dim 1 qui sépare
grp <- as.factor(res.km$cluster)
summary(grp)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, axes = c(1,2), geom = "point") 

for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  # print(v)
  t = table(grp, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2, "Pop de référence")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  # print(round(t[1:3,- dim(t)[2]],2))
     plot(round(t[1:3,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp == 2, ] %>% pull(v)))
}
```

Séparation entre usage fort, granulés, poêle / foyer fermé, moins riches, plus majorés, plus employés, un peu plus de rurales
Vs 
usage appoint, bûches,  foyer ouvert / fermé, plus riches; moins majorés, plus cadres, un peu plus d'urbains

Retraités entre deux

```{r, include=FALSE}
# Extraire les données des variables et des individus
var_coord <- as.data.frame(res.afdm$quali.var$coord)
contrib = rowSums(res.afdm$quali.var$contrib)
cos2 = rowSums(res.afdm$quali.var$cos2)
var_coord = var_coord[contrib >95 & cos2 > 0.95,]
ind_coord <- as.data.frame(res.afdm$ind$coord)
ind_coord$cluster <- grp

# Créer le plot pour les variables
plot <- ggplot() + 
  # Points pour les individus colorés par clusters
  geom_point(data = ind_coord, aes(x = Dim.1, y = Dim.2, color = factor(cluster))) +
  # Textes pour les catégories des variables
  geom_text(data = var_coord, aes(x = Dim.1, y = Dim.2, label = rownames(var_coord)),
            color = "red", size = 3.5)  +
  scale_color_manual(values = c("#0073C2FF", "#EFC000FF")) +
  theme_minimal() +
  labs(title = "Biplot des Variables et des Individus",
       x = "Dim 1",
       y = "Dim 2")

print(plot)
# xlim et ylim
```

Distance intra et inter clusters :
```{r}
# compute intercluster distances and intracluster diameters
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```


#### Cartographie des clusters :

Récupération des délimitaions des communes et des territoires : 
```{r, include=FALSE}
# Get polygons communes data
sql <- "SELECT insee_com, nom_m AS nom_commune, the_geom 
        FROM bd_admin_express.geo_commune_2022
        WHERE insee_dep = '38'
		    ORDER BY 1"
layer_communes <- st_read(con, query = sql)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]

shp <- st_read(dsn = "../data/EPCI 2024_region.shp")
shp = shp[c(27, 175, 929),]
shp$ sociale <- c("CCLG", "GAM", "CAPV")
```

```{r}
data_afmd$grp = grp
```

Carto avec un gradient de couleur selon le taux d'indivdus du groupe 2 par commune :
```{r, include=FALSE}
data_plot <- data_afmd %>% left_join(data[, c("N..dossier", "insee_com")], by = "N..dossier")
data_plot <- data_plot[!duplicated(data_plot$N..dossier),]
# data_plot <- data_plot %>% group_by(insee_com, grp) %>%    summarise(n = n()) %>%
#     mutate(percentage = n / sum(n) * 100)
data_plot <- data_plot %>% group_by(insee_com) %>% summarise(taux_gp2 = round(mean(as.numeric(grp)) - 1,3))
to_plot <- left_join(layer_communes, data_plot[,c("insee_com", "taux_gp2")], by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
    geom_sf(aes(fill = taux_gp2)) +
scale_fill_gradient(low = "blue", high = "yellow", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = taux_gp2), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
ggsave("../carto/carte_clusters_individus.png", width = 20, height = 20, units = "cm")
```

Carto intéractive :
```{r}
# Convertir l'objet ggplot en plotly
plotly_plot <- ggplotly(plot, tooltip = c("label", "label1","label2"))

# Afficher la carte interactive
plotly_plot
htmlwidgets::saveWidget( widget = plotly_plot, file =  "../carto/carte_clusters_individus_interactive.html")
```


#### Odds et risks ratios :

Odds-ratios : 

```{r}
# créer une fonction pour comparer chaque modalité à toutes les autres
to_bin <- function(v,m){
  vec = c()
  for(a in data_afmd %>% pull(v)){
    if(a == m) vec = c(vec,1)
    else vec = c(vec,0)
  }
  return(vec)
}
or = c()
inf = c()
sup = c()
mod = c()
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  for(m in levels(data_afmd %>% pull(v))){
    if(m != "0"){ # pour ne prendre que la modalité "1" == "oui", des variables binaires + que le cluster des communes 1
    bin = to_bin(v,m)
    mod = c(mod,paste(v, m, sep = "."))
    res <-tryCatch(
      expr = {
    res = oddsratio(bin, grp)$measure[2,]
        },
    error = function(err){
            c(NA, NA, NA)
        }
    )
    or = c(or, res[1])
    inf = c(inf, res[2])
    sup = c(sup, res[3])
    if(length(levels(data_afmd %>% pull(v))) == 2) break # pour ne prendre que la première modalité des variables binaires != 0/1, (ex : majoration)
    }
  }
}

odr = data.frame(modalité = mod, OR = or, borne_2.5 = inf, borne_97.5 = sup)

odr = odr[order(odr$OR, decreasing =  FALSE),]
odr$log_or = log(odr$OR)
odr$log_inf = log(odr$borne_2.5)
odr$log_sup = log(odr$borne_97.5)

na.omit(odr) %>% ggplot(aes(y = modalité , x = log_or, color = log_or)) +
  geom_point(size = 3) + # Points pour les valeurs de log_or
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90",  high = "#EFC000FF", midpoint = 0) +
  coord_cartesian(xlim = c(-5, 5)) +
  labs(title = "Log Odds Ratios with Confidence Intervals",
       y = "Group",
       x = "Log Odds Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
ggsave("../data/3_Resultat/graphes/Clusters/Individus/odds_ratios.png", device = "png", bg = "white", width = 20, height = 20, units = "cm")
```

```{r}
write_xlsx(odr, "../data/3_Resultat/OR_afdm.xlsx")
write_xlsx(odr, "../shinyapp/www/data/OR_afdm.xlsx")
```


L'odds ratio est le rapport de la cote qu'un évenement (ici être dans le groupe 2) arrive à un groupe d'individus A par rapport à celle d'un groupe B.

Le kisks ratio est la même chose mais avec les probabilités à la place des cotes.
 Un log(odds ratio) : 
 
 < 0 signifie que l'événement "être dans le groupe 2" est moins fréquent dans ce groupe par rapport à l'ensemble des autres, signifatif si la borne sup l'est aussi.
 
= 0 signifie que l'événement est aussi fréquent dans les deux groupes.

 '>' 0 signifie que l'événement "être dans le groupe 2" est plus fréquent dans ce groupe par rapport à l'ensemble des autres, signifatif si la borne inf l'est aussi.
 
 On ne peut pas calculer l'OR pour les communes peu dense et très peu dense car elles sont trop peu nombreuses.

Pareil pour le risque ratio.

Risk ratio : 

```{r}
rr = c()
inf = c()
sup = c()
mod = c()
for(v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))){
  for(m in unique(data_afmd %>% pull(v))){
    if(m != "0"){ # pour ne prendre que la modalité "1" == "oui", des variables binaires
    bin = to_bin(v,m)
    mod = c(mod,paste(v, m, sep = "."))
    res <-tryCatch(
      expr = {
    res = riskratio(bin, grp)$measure[2,]
        },
    error = function(err){
            c(NA, NA, NA)
        }
    )
    rr = c(rr, res[1])
    inf = c(inf, res[2])
    sup = c(sup, res[3])
    if(length(levels(data_afmd %>% pull(v))) == 2) break # pour ne prendre que la première modalité des variables binaires != 0/1, (ex : majoration)
    }
  }
}

risk_ratio = data.frame(modalité = mod, RR = rr, borne_2.5 = inf, borne_97.5 = sup)
risk_ratio = risk_ratio[order(risk_ratio$RR, decreasing =  FALSE),]
risk_ratio$log_rr = log(risk_ratio$RR)
risk_ratio$log_inf = log(risk_ratio$borne_2.5)
risk_ratio$log_sup = log(risk_ratio$borne_97.5)

risk_ratio %>% ggplot(aes(y = modalité, x = log_rr, color = log_rr)) +  # reorder(modalité, log_rr)
  geom_point(size = 3) + 
  geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
  scale_color_gradient2(low = "#0073C2FF", mid = "grey90",  high = "#EFC000FF", midpoint = 0) +
  coord_cartesian(xlim = c(-4, 4)) +
  labs(title = "Log risk Ratios with Confidence Intervals",
       y = "Group",
       x = "Log risk Ratio") +
  geom_vline(xintercept = 0, linetype="dotted") +
  theme_minimal()
ggsave("../data/3_Resultat/graphes/Clusters/Individus/risk_ratios.png", device = "png", bg = "white", width = 20, height = 20, units = "cm")
```

Grands intervalles de confiance : La où il y a de petits effectifs

Jaune = groupe 2 : résultats signficatifs : log(bornes 2.5 %) > 0 <=> bornes 2.5% >1
Bleu = groupe 1 : résultats signficatifs : log(bornes 97.5 %) <  <=> bornes 97.5 % <1



Globalement, les modalités amenant le plus à être dans le groupe 2 sont : Chauffage principal dans l'usage de l'ancien et du nouvel appareil, une fréquence d'utilisatrion "tous les jours", et avoir un nouveau poêle au granulés.

Celles amenant le plus à ne pas être dans le groupe 2, dont à être dans le groupe 1 sont : Les usages plaisir/a gréments et d'appoint pour les nouveaux et anciens appareils. Avoir un ancien appareil de type "foyer ouvert", et avoir un revenu supérieur à 100 000€ par an


#### Régression logistique :

Calcul du modèle prédisant le cluster : 
```{r}
# sans les doublons
rl = glm(grp~., data = data_afmd[,setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage"))],  family = binomial(logit))
```

Différents indicateurs : 
```{r}
# s = summary(rl)
# Coefficients du modèle
# coefficients <- coef(rl)
# 
# # Calcul des odds ratios
# odds_ratios <- exp(coefficients)
# odds_ratios

# library(questionr)
# odr = odds.ratio(rl)
# coeff = as.data.frame(rl$coefficients)
# s$r.squared
```
 Les OR sont absurdes
```{r, eval = FALSE}
# # avec un régression logistique :
# odr = odr[order(odr$OR, decreasing =  FALSE),]
# odr$log_or = log(odr$OR)
# odr$log_inf = log(odr$`2.5 %`)
# odr$log_sup = log(odr$`97.5 %`)
# odr$groupe_entree = row.names(odr)
# 
# odr[odr$groupe_entree != "(Intercept)",] %>% ggplot(aes(y = reorder(groupe_entree, log_or) , x = log_or, color = log_or)) +
#   geom_point(size = 3) + # Points pour les valeurs de log_or
#   geom_errorbar(aes(xmin = log_inf, xmax = log_sup), width = 0.2) + # Barres d'erreur pour les intervalles de confiance
#   scale_color_gradient2(low = "blue", mid = "grey90", high = "red", midpoint = 0) +
#   coord_cartesian(xlim = c(-40, 40)) +
#   labs(title = "Log Odds Ratios with Confidence Intervals",
#        y = "Group",
#        x = "Log Odds Ratio") +
#   geom_vline(xintercept = 0, linetype="dotted") +
#   theme_minimal()
```



Essaie régression logistique en sélectionnant les variables
```{r}
# rl = lm(taux_dossiers_habitant~. -insee_com - commune - Territoire - taux_dossiers_menages - n - taux_dossiers_maisons, data = data_test)
# s = summary(rl)
# s$r.squared
# , "nb_ménages_fiscaux", "n","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022")
```




### Avec 3 groupes :

```{r}
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 3, nstart = 25) # séparation dim 1 et 2
grp3 <- as.factor(res.km$cluster)
summary(grp3)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp3, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2), ) 

# fviz_famd_var(res.afdm, col.var = "bisque4", "var", repel = TRUE, select.var = list("contrib" = 20))
for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  # print(v)
  t = table(grp3, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2,3, "Pop totale")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  # print(round(t[1:4,- dim(t)[2]],2))
   plot(round(t[1:4,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp3 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp3 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp3 == 3, ] %>% pull(v)))
}
```

Distance intra et inter clusters :
```{r}
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```
Pas forcément pertinent, un groupe plus "Pas de réponse", séparation selon le stockage.

### Avec 4 groupes :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 4  , nstart = 25)
grp4 <- as.factor(res.km$cluster)
summary(grp4)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp4, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2))


for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  # print(v)
  t = table(grp4, data_afmd %>% pull(v))
  t = as.table(rbind(t, table(data_afmd %>% pull(v))))
  row.names(t) <- c(1,2,3,4, "Pop totale")
  t = t(addmargins(t))
  t = t(t) / t[dim(t)[1],]
  # print(round(t[1:5,- dim(t)[2]],2))
  plot(round(t[1:5,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  # print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp4 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp4 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp4 == 3, ] %>% pull(v)))
  print("Groupe 4 : ")
  print(mean(data_afmd[grp4 == 4, ] %>% pull(v)))
}
```


Distance intra et inter clusters :
```{r}
cls.scatt1 <- cls.scatt.data(res.afdm$ind$coord, res.km$cluster)
cls.scatt1$intracls.average
cls.scatt1$intercls.average
```
Pas forcément pertinent, un groupe "Pas de réponse", séparation aussi selon le stockage



```{r}
# Pour comparer avec les résultats d'autres clustering / d'autres réductions de dimension
# corresp_clusters <- data.frame(num_doss = data_afmd$N..dossier, cluster_tt = grp)
# corresp_clusters <- corresp_clusters[!corresp_clusters$num_doss %in% corresp_clusters[which(duplicated(corresp_clusters$num_doss)),]$num_doss,]
# write.csv(corresp_clusters, "../data/2_Travail/Clusters individus.csv")
```

### Avec 5/6 groupes :

```{r, include = FALSE}
# Créez une variable de regroupement en utilisant kmeans
set.seed(3)
res.km <- kmeans(res.afdm$ind$coord, centers = 6, nstart = 25)
grp5 <- as.factor(res.km$cluster)
summary(grp5)
# Colorer les variables par groupes
fviz_famd_ind(res.afdm, habillage = grp5, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE, geom = c("point"), axes = c(1,2))

# Sans prendre en comlpte le cluster "Pas de réponse"  :
for( v in setdiff(utilisation, c("cout_total_TTC","montant_aide", "Nb.pers.ménage") )){
  # print(v)
  t = t(addmargins(table(grp5, data_afmd %>% pull(v))))
  t = t(t) / t[dim(t)[1],]
  # print(round(t[1:6,- dim(t)[2]],2))
  plot(round(t[1:6,- dim(t)[2]],2), col = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink","purple", "brown", "white"), las=1, main = v)
}

for( v in c("cout_total_TTC","montant_aide", "Nb.pers.ménage")){
  print(v)
  print("Groupe 1 : ")
  print(mean(data_afmd[grp5 == 1, ] %>% pull(v)))
  print("Groupe 2 : ")
  print(mean(data_afmd[grp5 == 2, ] %>% pull(v)))
  print("Groupe 3 : ")
  print(mean(data_afmd[grp5 == 3, ] %>% pull(v)))
  print("Groupe 4 : ")
  print(mean(data_afmd[grp5 == 4, ] %>% pull(v)))
  print("Groupe 5 : ")
  print(mean(data_afmd[grp5 == 5, ] %>% pull(v)))
}
```

Pas fou, pas fou


Correspondances entre les groupes des 4 clustering :
```{r}
table(grp, grp3)
table(grp, grp4)
table(grp, grp5)
table(grp3, grp4)
table(grp3, grp5)
table(grp4, grp5)
```


### Choix nb clusters :

Proportion d'inertie expliqué selon le nb de groupes
```{r}
inertie.expl=c() 
for (k in 2 :10){
  clus <- kmeans(res.afdm$ind$coord, centers=k,nstart=5)
  inertie.expl[k] <- clus$betweenss/clus$totss
}
plot(1 :10,inertie.expl,type="b",xlab="Nb. de groupes",ylab="% inertie expliquée")

```

-> Pas de coude, difficile de faire un choix.

Critère de Calinski et Harabasz : prends en compte la taille de l'échantillon, le nombre de cluster, et les sommes des carrés des distances intra et inter clusters : critère à maximiser

```{r}
k.event.cal <- cascadeKM(res.afdm$ind$coord, 2, 6, iter = 100, criterion = "calinski")
plot(k.event.cal)
```
Clairement 2 clusters

#### Récupération des clusters : 

```{r}
# Attention à ne pas les mettre plusieurs fois :
entree <-  read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
duplicated = unique(data[which(duplicated(data$N..dossier)),"N..dossier"])
sortie <- data_afmd[!data_afmd$N..dossier %in% duplicated$N..dossier , c("N..dossier", "grp")]
names(sortie) <- c("N..dossier", "cluster_ind")
sortie <- left_join(entree, sortie, by = "N..dossier")
# write_xlsx(sortie, "../data/3_Resultat/data_questionnaire_complet.xlsx")

plot(table(format(entree[entree$cluster_ind == "1" ,]$dossier_reçu, "%Y"))[-c(1,2,11)] / table(format(entree$dossier_reçu, "%Y"))[-c(1,2,11)],
     type = "l", col ="pink", main = "évolution des taux de demandeurs par cluster", ylab = "")
lines(table(format(entree[entree$cluster_ind == "2" ,]$dossier_reçu, "%Y"))[-c(1,10)] / table(format(entree$dossier_reçu, "%Y"))[-c(1,2,11)], 
      type = "l", col ="purple")
lines(table(format(entree[is.na(entree$cluster_ind) ,]$dossier_reçu, "%Y"))[-c(1,10)] / table(format(entree$dossier_reçu, "%Y"))[-c(1,2,11)], 
      type = "l", col ="gray")
legend("bottomleft", legend=c("1", "2", "NA"),  col=c("pink","purple", "gray"), lty=1, cex=0.8, bg="transparent", title = "Clusters")
# de moins en moins de gros consommatteurs

# Si les clusters n'ont pas encore été ajouté au jeu de donnée : 
# plot(table(format(sortie[sortie$cluster_ind == "1" ,]$dossier_reçu, "%Y"))[-c(1)] / table(format(sortie$dossier_reçu, "%Y"))[-c(1)],
#      type = "l", col ="pink", main = "évolution des taux de changement de type de combustible")
# lines(table(format(sortie[sortie$cluster_ind == "2" ,]$dossier_reçu, "%Y")) / table(format(sortie$dossier_reçu, "%Y"))[-c(1)], 
#       type = "l", col ="purple")
# legend("bottomleft", legend=c("1", "2"),  col=c("pink","purple"), lty=1, cex=0.8, bg="transparent")
```

Le taux de demandeurs du groupe 1 augmente depuis 2022.

```{r}
entree <- entree[entree$dossier_reçu >= "2016-01-01" & entree$dossier_reçu < "2024-01-01" & !is.na(entree$dossier_reçu),] 
for(territoire in c("GAM", "CAPV", "CCLG")){
  
plot(table(format(entree[entree$cluster_ind == "1" & entree$Territoire == territoire,]$dossier_reçu, "%Y")) / table(format(entree[entree$Territoire == territoire,]$dossier_reçu, "%Y")),
     type = "l", col ="pink", main = paste("Évolution des taux de demandeurs par cluster à : ",territoire ), ylab = "", ylim = c(0,1))
lines(table(format(entree[entree$cluster_ind == "2" & entree$Territoire == territoire,]$dossier_reçu, "%Y")) / table(format(entree[entree$Territoire == territoire,]$dossier_reçu, "%Y")), 
      type = "l", col ="purple")
lines(table(format(entree[is.na(entree$cluster_ind) & entree$Territoire == territoire,]$dossier_reçu, "%Y")) / table(format(entree[entree$Territoire == territoire,]$dossier_reçu, "%Y")), 
      type = "l", col ="gray")
legend("topleft", legend=c("1", "2", "NA"),  col=c("pink","purple", "gray"), lty=1, cex=0.8, bg="transparent", title = "Clusters")
}


```

Le taux de demandeurs du groupe 1 augmente depuis 2022 dans tous les territoires. Le taux du groupe 2 (plus consommateurs) est plus fort dans le Pays Voironnais, alors que c'est celui du groupe 1 à Grenoble Métropole. C'est plus mitigé dans le Grésivaudan.

Aussi, c'est dans le pays voironnais qu'on observe le plus grand taux de non admissions à un cluster : les individus qu'on n'a pas exploités car ils présentaient des données manquantes ou des "Pas de réponses", et en particulier en 2020.

### Exploration avec Factoshiny : 


```{r, include = FALSE}
# library(Factoshiny)
# FAMDshiny(data_afmd[,-1]) 
```



## Conclusion : 

On a choisi de séparer les individus en deux groupes : 

Globalement le groupe 1 est caractérisé par un usage d'appoint et de plaisir de leurs appareils, un ancien appareil de type foyer ouvert ou fermé, l'utilisation principalement de la bûche, les bénéficiaires de ce groupe semblent avoir des revenus plus importants, et a des taux plus forts de bénéficiaires cadres et de bénéficiaires vivant dans des communes urbaines denses que le groupe 2.

Les individus du groupe 2 eux, ont une utilisation plus importante de leurs appareils, donc utilisent souvent leurs appareils et comme chauffage principal, se chauffent un peu plus aux granulés qu'à la bûche, ont principalement des poêles, ont des revenus moins importants et donc plus de primes majorées.
Dans ce groupe, il y a un taux plus importants de bénéficiares employés  et de bénéficiaires ouvriers, ainsi que de bénéficiaires vivant dans des communes rurales que dans le groupe 1.

Le taux de demandeurs du groupe 1 semble augmenter depuis 2022.

Nous n'obtenons pas de résultats pertinents en séparant les individus selon leur type de combustible.