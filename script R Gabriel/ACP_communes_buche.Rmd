---
title: "ACP communes"
author: "Gabriel Macé"
date: "2024-06-18"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning= FALSE)
```

```{r, include=FALSE}
library(readxl)
library(writexl)
library(stringr)
library(tidyr)
library(sf)
library(dplyr)
library(stats)
library(ggplot2)
library(stats)
library(factoextra)
library(FactoMineR)
library(corrplot)
library(fastDummies)
library(plotly)
library(reshape2)
```

```{r}
wd_script <- "C:/Users/gmace/PAB/Projet Bois-buche/scripts/R"
setwd(wd_script)
con_encoding <- "UTF-8"
source("R_connect_siddt.R")
source("R_functions.R")
setwd("C:/Users/gmace/PAB/Projet Bois-buche/script R Gabriel")
```

```{r}
data <- read_excel("../data/3_Resultat/data_questionnaire_complet.xlsx")
data <- data[!data$insee_com %in% c("38453","38278", "38526", "38194", "38118", "38013", "38248", "38450", "38236", "38412", "38405", "38442", "38446", "38378"),]
data <- data[!data$Type.Ancien.appareil %in% c("Chaudière","Cuisinière"),]
data[data$Nouveau.matériel %in% c("Poêle de masse", "Poêle hydraulique"),]$Nouveau.matériel <- "Poêle"
data <- data[!data$Nouveau.matériel %in% c("Chaudière","Cuisinière"),]
data <- data[data$Type.combustible.nouveau.materiel == "Bûche",] 

binaire <- read_excel("../data/2_Travail/export_questionnaire_binaire.xlsx")
binaire <- binaire[binaire$`N° dossier` %in% data$N..dossier,]
binaire_buche <- binaire[,c(1,31,50:54)]
binaire_buche <- binaire_buche[binaire_buche$`Type combustible nouveau materiel` == "Bûche",]
binaire_buche <- left_join(binaire_buche, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire_buche <- binaire_buche[!duplicated(binaire_buche$`N° dossier`),c(2:7)]
binaire <- binaire[,c(1,50:54)]
binaire <- left_join(binaire, data[, c("insee_com", "N..dossier")],  by = join_by("N° dossier" == "N..dossier"), )
binaire <- binaire[!duplicated(binaire$`N° dossier`),c(2:7)]


```


```{r}
data_acp <- data[,c(1,43)] %>% group_by(insee_com) %>% count()

#quanti = c("cout_total_TTC", "montant_aide","cout_appareil") # , "équivalent_steres"
quali = c("Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Usage.nouveau.matériel", "majoration"
          )
#  "Année.installation",
for(col in quali){
df_long <- data[,c(col, "insee_com")]
df_long <- dummy_cols(df_long, select_columns = col, remove_first_dummy = FALSE, remove_selected_columns = TRUE)
df_binary <- df_long %>%
    group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, df_binary, by = "insee_com")
}



df <- data[,c("insee_com","cout_total_TTC")] %>% group_by(`insee_com`) %>% summarise(cout_total_TTC = mean(na.omit(cout_total_TTC)))
data_acp <- left_join(data_acp, df, by = "insee_com")

binaire2 <- binaire_buche %>% group_by(`insee_com`) %>% summarise(across(everything(), sum , na.rm = TRUE)) 
data_acp <- left_join(data_acp, binaire2, by = "insee_com")

for(i in 3:dim(data_acp)[2]){
  data_acp[,i] = data_acp[,i] / data_acp$n
}
terr = data[,c("Territoire","insee_com")]
terr = terr[!duplicated(terr$insee_com),]
data_acp <- left_join(data_acp, terr, by = "insee_com")
```




```{r, include=FALSE}
comm <- read.csv("../data/siddt.csv", sep = ";", skip = 2)[-c(124:130),c(1,2, 3,4,6)]
comm2 <- read.csv("../data/siddt2.csv", sep = ";", skip = 2)[-c(124:130),c(1, 3:5)]
logement = read.csv("../data/logements_2020.csv", sep =";", skip= 2)[-c(124:130),c(1,3)]
objectifs_communes <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[1:123,1:4]
oc <- read_excel("../data/objectifs_communes_2022_2023.xlsx")[124:239,c(2,4)]
objectifs_communes <- left_join(objectifs_communes, oc, by = "id_comm")
objectifs_communes$id_comm = as.character(objectifs_communes$id_comm)
objectifs_communes = objectifs_communes[,c(2,4,5)]
names(objectifs_communes)= c("insee_com", "objectifs_2022", "changement_2023")
objectifs_communes$changement_2023 = abs(objectifs_communes$changement_2023)
objectifs_communes[is.na(objectifs_communes$changement_2023), "changement_2023"] <- 0
revenus_communes <- read_xlsx("../data/revenu_communes_insee.xlsx", skip = 5, col_names = TRUE)
revenus_communes <- revenus_communes[revenus_communes$CODGEO %in% data$insee_com,]
revenus_communes = revenus_communes[, c(1, 3:5)]
names(revenus_communes) = c("insee_com", "nb_ménages_fiscaux", "nb_personnes_menages_fiscaux", "mediane_niveau_vie")
types_communes <- read_excel("../data/types_communes.xlsx", sheet = 4, skip = 2, col_names = TRUE)
names(types_communes) <- c("insee_com", "type_commune")
types_communes$type_commune <- factor(types_communes$type_commune, levels = c("rural autonome très peu dense", "rural autonome très peu dense", "rural sous faible influence d'un pôle", "rural sous forte influence d'un pôle", "urbain densité intermédiaire", "urbain dense"))
surf_bois <- read_excel("../data/surface_boisee_off_2023.xlsx", sheet = "données")
surf_bois = surf_bois[surf_bois$`INSEE commune` %in% data$insee_com,c("INSEE commune", "Surface commune", "feuillus", "mixtes")]
```


```{r}
count <- data %>%
  group_by(insee_com) %>%
  count()
fo <- data[data$Type.Ancien.appareil != "Foyer ouvert",] %>%
  group_by(insee_com) %>%
  count()
buche <- data[data$Type.combustible.nouveau.materiel == "Bûche",] %>%
  group_by(insee_com) %>%
  count()
maj <- data[data$majoration == "M",] %>% group_by(insee_com) %>% count()
names(comm) <- c("communes.depcom","commune", "superficie_foret", "taux_forets", "évolution_nb_logements")
data_test = left_join(count, comm, by = join_by("insee_com" == "communes.depcom"))
names(comm2) <- c("communes.depcom", "Densité_pop", "Part_résidences_principales_loc", "part_maisons")
data_test <- data_test %>% left_join(comm2, by = join_by("insee_com" == "communes.depcom"))
names(logement) = c("insee_com", "nb_maisons_rp_2020")
data_test <- data_test %>% left_join(logement, by = "insee_com")
data_test <- data_test %>% left_join(types_communes, by = "insee_com")
data_test <- data_test %>% left_join(objectifs_communes, by = "insee_com")
data_test <- data_test %>% left_join(revenus_communes, by = "insee_com")
data_test <- na.omit(data_test)
data_test[, "taux_dossiers_habitant"] = data_test$n / as.numeric(data_test$nb_personnes_menages_fiscaux)
data_test[, "taux_changement"] = data_test$changement_2023 / data_test$objectifs_2022
data_test[, "objectifs_2022_par_maison"] = data_test$objectifs_2022 / data_test$nb_maisons_rp_2020
data_test[, "taux_feuillus"] = surf_bois$feuillus / surf_bois$`Surface commune`
data_test[, "taux_feuillus_mixte"] = (surf_bois$feuillus + surf_bois$mixtes) / surf_bois$`Surface commune`
```



# <span style="color: red;"> <u> Demandeurs dont le nouvel appareil fonctionne à la buche : </u> </span>

## Test de normalité de Shapiro-Wilk :

Nous allons tester la normalité des distributions, afin d'identifier un éventuel effet "commune".

Si les comportements des bénéficiaires sont les mêmes dans chaque commune, alors les distributions devraient être normales.

H0 : "La distribution suit une loi normale".

Etant donné que je fais 25 tests, j'utilise la correction de Benjamin-Hochberg :

```{r, include = FALSE}
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
pval = c()
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
    qqnorm(data_acp %>% pull(col), main = col)
  plot(density(data_acp %>% pull(col)), main = col)
    pval = c(pval, shapiro.test(data_acp %>% pull(col))$p.value) # H0 : la distribution suit une loi normale
}
res = data.frame(var = setdiff(names(data_acp), c("insee_com","Territoire")), p_valeur =  p.adjust(pval, method = "BH", n = length(pval)))
```

Aucune des variables n'est normalements distribuées.
```{r, include = FALSE}
# Les variables ne suivant pas une loi normale :
res[res$p_valeur < 0.05,]
```


```{r, include = FALSE}
# Les variables normalement distribuées :
res[res$p_valeur > 0.05,] # que 2 distributions normales
```






## ACP :

Je ne garde pas les communes ayant moins de 10 dossiers

Variables utilisées : 
"Type.Ancien.appareil", "Usage.ancien.matériel",  "Nouveau.matériel","Type.combustible.nouveau.materiel", "Usage.nouveau.matériel", "majoration", "cout_total_TTC, et "Motivation changement appareil"

J'enlève les variables représentant les modalités de type "autre", "pas de réponse, "NA", et une des modalités des variables devenues binaires (combustible, majoration)
```{r}
data_acp <- data_acp[,setdiff(names(data_acp),c("Type.Ancien.appareil_Pas de réponse", "Usage.ancien.matériel_Pas de réponse", "Nouveau.matériel_Pas de réponse", "Type.combustible.nouveau.materiel_autre","Type.combustible.nouveau.materiel_Bûche, autre", "Type.combustible.nouveau.materiel_Bûche, Granulés", "Type.combustible.nouveau.materiel_Pas de réponse", "Usage.nouveau.matériel_Pas de réponse", "majoration_NA"
                                                ,"Nouveau.matériel_Insert / foyer fermé",  "majoration_NM"
                                                # , "Qualité air de mon logement","Économiser du bois/énergie","Économiser de l'argent","Gagner en confort/chaleur", "Qualité de l'air extérieur"
))]

# variable devenues binaires :
# ,"Nouveau.matériel_Insert / foyer fermé", "Type.combustible.nouveau.materiel_Granulés", "majoration_NM"
for(col in setdiff(names(data_acp), c("insee_com","Territoire"))){
  data_acp[,col] <- as.numeric(data_acp %>% pull(col))
}
for(col in setdiff(names(data_test), c("insee_com","commune","type_commune"))){
  data_test[,col] <- as.numeric(data_test %>% pull(col))
}
```

```{r, include = FALSE}
data_acp <- data_acp[data_acp$insee_com %in% data_test$insee_com,]
data_acp = data_acp[data_acp$n >= 10,]
df = left_join(data_acp, data_test[,setdiff(names(data_test),c("n","commune"))], by = "insee_com")
res.pca <- PCA(df[, 2:dim(df)[2]], quanti.sup = c("n", setdiff(names(data_test),"type_commune")), quali.sup = c("Territoire","type_commune"), ncp = 10)
```
### Valeurs propres :
```{r}
eig.val <- get_eigenvalue(res.pca)
head(eig.val, n = 10)
```
Les 7 premières dimensions expliquent plus de 80% de la vairance, on gardera quand même les 10 premières pour les clusterings.

```{r}
#row.names(res.pca$ind$coord) <- na.omit(data_afdm)$commune
fviz_pca_ind(res.pca, habillage = "Territoire", palette = c("green","red", "blue"))
```

Il semble y avoir une légère séparation par territoire, sur les deux premières dimensions.

```{r}
fviz_pca_var(res.pca, select.var = list("contrib" = 10))
```

### Contribution et représentation des variables : 

```{r}
var = get_pca_var(res.pca)
corrplot(var$cos2[,1:10], is.corr = FALSE) 
corrplot(var$contrib[,1:10], is.corr = FALSE) 
fviz_contrib(res.pca, choice = "var", axes = c(1,2))
fviz_cos2(res.pca, choice = "var", axes = c(1,2))
```
Les variables de raisons de changement d'appareil, et le cout ttc des travaux ne semblent pas très importants.
Les autres semblent toutes assez bien représentées par les deux premières dimensions.

### Type de communes  :

```{r}
#fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5"))
fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 3), "red", "red"))
#fviz_pca_ind(res.pca, habillage = "type_commune", palette = c(rep("blue", 3), rep("green",2), "red"))
# fviz_pca_ind(res.pca, habillage = "type_commune", palette = c("yellow","yellow", "orange", "red", "brown", "black"))
```
Les deux premières dimensions semblent bien séparer les communes urbaines des rurales


## Clustering :
### Clustering ascendant hiérarchique : 

```{r}
row.names(res.pca$ind$coord) <- data_acp[data_acp$n >= 10,]$insee_com
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D")
plot(hc)
rect.hclust(hc,k=2)
hc <- hclust(dist(res.pca$ind$coord), method = "ward.D2")
plot(hc)
rect.hclust(hc,k=2)
memb <- as.factor(cutree(hc, k = 2))
fviz_pca_ind(res.pca, col.ind = memb, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
```

Le dendogramme semble suggérer de créer 2 clusters.

### K-means :

```{r}
# Créez une variable de regroupement en utilisant kmeans
set.seed(4730)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)# Créez 3 groupes de variables (centers = 3)
grp <- as.factor(res.km$cluster)
# Colorer les variables par groupes
fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
```

(38472 = Sarcenas, 38080 = Charancieu)

La méthode k-means semble bien séparer les deux groupes, en particulier selon la première dimension.



```{r}
fviz_pca_biplot(res.pca, col.var = "bisque4", label = c( "var"), select.var = list("contrib" = 7), col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"),repel = TRUE)
```

```{r}
fviz_pca_biplot(res.pca, col.var = "transparent", label = "quanti.sup",  select.var = list("name" = c("n",setdiff(names(data_test), c("insee_com", "commune", "Territoire", "nb_ménages_fiscaux","nb_personnes_menages_fiscaux", "Part_résidences_principales_loc", "changement_2023", "taux_dossiers_menages",	"taux_dossiers_maisons", "objectifs_2022", "surface_feuillus_mixte", "taux_forets", "taux_dossiers_habitant", "objectifs_2022_par_maison")))), col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), repel = TRUE)
```


### Carte des clusters : 


```{r}
# Get polygons communes data
sql <- "SELECT insee_com, nom_m AS nom_commune, the_geom 
        FROM bd_admin_express.geo_commune_2022
        WHERE insee_dep = '38'
		    ORDER BY 1"
layer_communes <- st_read(con, query = sql)
layer_communes <- layer_communes[layer_communes$insee_com %in% unique(data$insee_com),]

shp <- st_read(dsn = "../data/EPCI 2024_region.shp")
shp = shp[c(27, 175, 929),]
shp$ sociale <- c("CCLG", "GAM", "CAPV")
```

```{r}
grp <- data.frame(grp)
grp$insee_com = rownames(grp)
to_plot <- left_join(layer_communes, grp, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = grp)) +
  #scale_fill_gradient(low = "white", high = "blue", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = grp), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

## Carte du type de commune
```{r}
tp2 = types_communes[types_communes$insee_com %in% data$insee_com,]
levels(tp2$type_commune) <- c("rural", "rural", "rural","rural", "urbain", "urbain")

to_plot <- left_join(layer_communes, tp2, by = "insee_com")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  #scale_fill_gradient(low = "white", high = "blue", na.value = "grey80") +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

```{r}
to_plot <- left_join(layer_communes, types_communes, by = "insee_com")
col = c("#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5")
# Créer un objet ggplot
plot <- ggplot(to_plot) +
  geom_sf(aes(fill = type_commune)) +
  scale_fill_manual(values = c("rural autonome peu dense" = col[1], "rural autonome très peu dense" = col[2], "rural sous faible influence d'un pôle" = col[3], "rural sous forte influence d'un pôle" = col[4], "urbain densité intermédiaire" = col[5], "urbain dense" = col[6] )) +
  geom_sf_text(aes(label = nom_commune, label1 = insee_com, label2 = type_commune), size = 1, color = "transparent", na.rm = FALSE) +
  theme_void()
plot <- plot + 
  geom_sf(data = shp, aes(fill = Z_MOYEN), color = c("red", "blue", "green"), lwd = 1.2, fill = NA)
plot
```

## Lien entre les cluters et les types de communes
```{r}
table <- table(grp$grp, tp2[tp2$insee_com %in% data_acp$insee_com,]$type_commune)
table
```
Deux groupes : un mixte, un plus urbain

    rural urbain
  1    27     26
  2     5     37
  
Trois groupes : un urbain, un rural, un mixte

 rural urbain
  1    15      6
  2    16     34
  3     1     23
  
  
```{r}
t = t(addmargins(table))
t = t / t[,3]
t = t[1:2,1:2]
round(t,2)
```



```{r}
table2 <- table(grp$grp, types_communes[types_communes$insee_com %in% data_acp$insee_com,]$type_commune)
table2
```
Groupe 1 = rural sous faible influence d'un pôle, rural sous forte influence d'un pôle, urbain  intermédiaire

Groupe 2 = urbain + rurale sous forte influence d'un pôle

Urbain intermédiaire se sépare en deux

```{r}
t2 = t(addmargins(table2))
t2 = t2 / t2[,3]
t2 = t2[1:6,1:2]
round(t2,2)
```

```{r, include = FALSE}
ggplot(data = melt(t), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()

ggplot(data = melt(t2), aes(x = Var1, y = Var2, fill = abs(value)))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "yellow", high = "red", mid = "orange", 
   midpoint = 0.5, limit = c(0,1), space = "Lab") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 8, hjust = 1))+
 coord_fixed()
```


```{r}
# # Créez une variable de regroupement en utilisant kmeans
# set.seed(23)
# res.km <- kmeans(res.pca$ind$coord, centers = 6, nstart = 25)# Créez 3 groupes de variables (centers = 3)
# grp <- as.factor(res.km$cluster)
# # Colorer les variables par groupes
# fviz_pca_ind(res.pca, col.ind = grp, palette = c("#0073C2FF", "#EFC000FF", "#868686FF","#FC4E07", "green", "orange", "pink"), legend.title = "Cluster",addEllipses = FALSE)
```




## Comparaison Urbain / rural

```{r}
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "rural",]$Type.combustible.nouveau.materiel_Bûche)
# mean(data_acp[tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune == "urbain",]$Type.combustible.nouveau.materiel_Bûche)

# data <- left_join(data, types_communes, by = "insee_com")
# data <- left_join(data, tp2, by = "insee_com")
# boxplot(data_acp$Type.combustible.nouveau.materiel_Bûche ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# boxplot(data_acp$Type.combustible.nouveau.materiel_Granulés ~ types_communes[types_communes$insee_com %in%data_acp$insee_com,]$type_commune)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.x)/ table(data$type_commune.x)
# table(data[data$Type.combustible.nouveau.materiel == "Granulés", ]$type_commune.y)/ table(data$type_commune.y)
# table(data[data$Type.combustible.nouveau.materiel == "Bûche", ]$type_commune.y)/ table(data$type_commune.y)
```


```{r}
# check <- data[, c("adresse_ville", "insee_com", "Type.combustible.nouveau.materiel", "type_commune.x")]
# check_gre <- check[check$adresse_ville %in% c("GRENOBLE"),c(3)]
# write_xlsx(check, "../data/3_Resultat/check_communes.xlsx")
# write_xlsx(check_gre, "../data/3_Resultat/check_Grenoble.xlsx")
```
## Différences inter-groupes : 

```{r}
# interprétation des variables / groupes
stat.comp <- function(x,y){
  K <- length(unique(y))# Nombre de groupes
  n <- length(x)# Nombre d’observations
  m <- mean(x)# Moyenne globale
  TSS <- sum((x-m)^2) # Variabilité totale
  nk <- table(y) # Effectifs conditionnels
  mk <- tapply(x,y,mean) # Moyennes conditionnelles
  BSS <- sum(nk * (mk - m)^2) # Variabilité expliquée
  result <- c(mk,100.0*BSS/TSS) # Moyennes + prop. variance expliquée
  names(result) <- c(paste("G",1 :K),"% epl.")# Nommer les élements du vecteur
  return(result) # Renvoyer le vecteur résultat
}

```


```{r}
data_test = data_test[data_test$n >=10, ]
data_test_cr = data_test
data_test_cr = data.frame(data_test_cr)
```

```{r}
for(i in setdiff(names(data_test), c("insee_com", "commune", "Territoire"))){
  data_test[,i] <- as.numeric(data_test %>% pull(i))
  data_test_cr[,i] <- scale(as.numeric(data_test %>% pull(i)))
}
```

```{r}
#set.seed(4730)
res.km <- kmeans(res.pca$ind$coord, centers = 2, nstart = 25)# Créez 3 groupes de variables (centers = 3)
grp <- as.factor(res.km$cluster)
```


### Variables de l'ACP :
Le tableau présente les différences de moyennes entre les deux groupes, pour les variables centrées réduites (cr) ou brutes, ainsi que la proportion de variance de la variable expliquée par la séparation en groupes (X..epl).

Il est ordonné selon la différence de moyennes  inter-groupes (pour les variables centrées réduites).

```{r}
var = setdiff(names(data_acp), c("insee_com","Territoire","n"))
df = data_acp[data_acp$n >= 10, var]
df = scale(df)
df = data.frame(df)
t = data.frame(round(sapply(df,stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_acp[data_acp$n >= 10, var],stat.comp,y=grp),2)) # tp2[tp2$insee_com %in%data_acp$insee_com,]$type_commune
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"

NB : J'ai aussi utilisé le test de Kruskal-Wallis, mais les résultats sont les mêmes que celui de Wilcoxon

```{r}
res = c()
anova = c()
#kw = c()
for(v in names(df)){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(df[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(df[,v]~grp))[[1]][1,5] )
  #kw <- c(kw, kruskal.test(df[,v]~grp)$p.value)
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
#p_value_corr_kw = p.adjust(kw, method = "BH", n = length(kw))
```


```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```


```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=1, col = "blue")
abline(v=-1, col = "blue")
```


```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr, 1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon","pval anova", "index")
dataf
```
Groupe 1 : (mixte urbain / rural)
```{r}
dataf[dataf$Diff_grp > 0 & dataf$`pval anova` < 0.05,]$variables
```
Majorés, chauffage principal, raison changement : plus de modalités / croisement, taux de poêle nouveau ++, ancien : plus d'insert


Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0 & dataf$`pval anova` < 0.05,]$variables
```

Non majorés, ont un usage moins important de leur appareil (moins dépendants),  ancien : + de foyer ouvert

```{r}
write_xlsx(dataf, "../data/3_Resultat/var_acp_buche.xlsx")
```


### Variables supplémentaires : 

```{r}
# rl ?
var = setdiff(names(data_test), c("insee_com", "type_commune", "commune", "Territoire", "changement_2023", "nb_maisons_rp_2020")) # , "n", "objectifs_2022"
t = data.frame(round(sapply(data_test_cr[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t)){
diff = c(diff,as.numeric(t["G 1",col]) - as.numeric(t["G 2",col]))
}
t["diff_inter_groupes_cr",] = diff


t2 = data.frame(round(sapply(data_test[,var],stat.comp,y=grp),2))
diff= c()
for(col in names(t2)){
diff = c(diff,as.numeric(t2["G 1",col]) - as.numeric(t2["G 2",col]))
}
ordre = data.frame(t(t[c("diff_inter_groupes_cr","% epl."),]))
ordre$diff_brute = diff
ordre = data.frame(ordre[order(abs(ordre$diff_inter_groupes_cr)),])
ordre
```

#### Tests comparaisons d'échantillons :

Tests non paramétrique d'égalité des distributions de Wilcoxon : H0 : "égalité des lois"

Tests paramétriques d'égalité d'espérances, via ANOVA :  H0 : "égalité des espérances"

```{r}
res = c()
anova = c()
#kw = c()
for(v in var){
  #res <- c(res,t.test(df[,v]~grp, var.equal = FALSE)$p.value)
  res <- c(res,wilcox.test(data_test_cr[,v]~grp)$p.value)
  anova <- c(anova, summary(aov(data_test_cr[,v]~grp))[[1]][1,5] )
  #kw <- c(kw, kruskal.test(data_test_cr[,v]~grp)$p.value)
}
p_value_corr = p.adjust(res, method = "BH", n = length(res))
p_value_aov_corr = p.adjust(anova, method = "BH", n = length(anova))
#p_value_corr_kw = p.adjust(kw, method = "BH", n = length(kw))
```



```{r}
plot(ordre$diff_inter_groupes_cr, p_value_corr,  xlim = c(-1.5, 1.5), ylim = c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue wilcoxon-test corrigée")# , col = "transparent"
text(ordre$diff_inter_groupes_cr, p_value_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```
```{r}
plot(ordre$diff_inter_groupes_cr, p_value_aov_corr, xlim = c(-1.5, 1.5), ylim=c(0,1), xlab = "Différence inter-groupes", ylab = "pvalue anova corrigée")
text(ordre$diff_inter_groupes_cr, p_value_aov_corr+0.05, cex = 0.7)
abline(h=0.05, col = "red")
abline(v=0.5, col = "blue")
abline(v=-0.5, col = "blue")
```


```{r}
dataf = data.frame(rownames(ordre), ordre$diff_inter_groupes_cr, p_value_corr, p_value_aov_corr,1:dim(ordre)[1])
colnames(dataf) = c("variables","Diff_grp", "pval wilcoxon", "pval anova", "index")
dataf
```

Groupe 1 : (mixte urbain / rural)
```{r}
dataf[dataf$Diff_grp > 0 & dataf$`pval wilcoxon` < 0.05,]$variables
```
+ forets, taux dossier et objectifs de changement / hab, part de maisons dans les résidences principales
Même que acp sur tous, sauf que tous les variables forêts sont plus importantes pour le groupe 1

Groupe 2 : (+ urbain)
```{r}
dataf[dataf$Diff_grp < 0 & dataf$`pval wilcoxon` < 0.05,]$variables
```
Clairement des caractéristiques urbaines : plus de pop, meilleur niveau de vie

```{r}
write_xlsx(dataf, "../data/3_Resultat/var_expl_buche.xlsx")
```

# Conclusion demandeurs bûches :

Suite à l'acp, nous avons chercher à créer des groupes de communes, le choix de séparer en deux groupes semble là aussi le plus optimal.

Le premier groupe semble être un mixte entre urbain et rural : il est composé à moitié de communes rurales (presque toutes), à moitié de communes urbaines à densité intermédiaire, mais  d'aucune urbaine dense.
Le deuxième groupe contient principalement des communes urbaines.

Les communes du premier groupe ont en moyenne un taux de prime majorées plus fort (8%), ont un taux plus fort de chauffage principal dans les nouveaux matériels (18%), ont 10 % de plus de pôele dans les noveaux matériels, et remplissent plus de réponses dans les raisons de changement d'appariel,  par rapport au deuxième groupe.

Le deuxième groupe a un usage moins important des appareils (appoint, plaisir), avant comme après prime, et a un taux plus fort de foyers ouverts dans les anciens appareils (18%).

Pour les variables supplémentaires, il semble y avoir plus de forêts dans le premier groupe, mais plus de population et une plus forte médiane de niveau de vie dans le deuxième.

Les résultats sont assez ressemblant à ceux sur l'ensemble des demandeurs, sauf qu'ici le premier groupe comprend plus de communes urbaines, et que les variables "forêts" sont toutes plus fortes pour le premier groupe.


